/* eslint-disable @typescript-eslint/no-use-before-define */
/* eslint-disable @typescript-eslint/naming-convention */
/* eslint-disable max-classes-per-file */
/* eslint-disable max-len */
// Autogenerated from typescript.template file

// TODO: Split this in multiple files
import { CustomElementJson } from '../core/model/custom-element-json';
import { DetectedElement } from '../core/model/annotation-result/detected-element';

export enum Separators {
  STRING = '<|string|>',
}

// LITERALS
export type INTERSECTION_AREA =
  | 'element_center_line'
  | 'element_edge_area'
  | 'display_edge_area';
export type PC_KEY =
  | 'backspace'
  | 'delete'
  | 'enter'
  | 'tab'
  | 'escape'
  | 'up'
  | 'down'
  | 'right'
  | 'left'
  | 'home'
  | 'end'
  | 'pageup'
  | 'pagedown'
  | 'f1'
  | 'f2'
  | 'f3'
  | 'f4'
  | 'f5'
  | 'f6'
  | 'f7'
  | 'f8'
  | 'f9'
  | 'f10'
  | 'f11'
  | 'f12'
  | 'space'
  | '0'
  | '1'
  | '2'
  | '3'
  | '4'
  | '5'
  | '6'
  | '7'
  | '8'
  | '9'
  | 'a'
  | 'b'
  | 'c'
  | 'd'
  | 'e'
  | 'f'
  | 'g'
  | 'h'
  | 'i'
  | 'j'
  | 'k'
  | 'l'
  | 'm'
  | 'n'
  | 'o'
  | 'p'
  | 'q'
  | 'r'
  | 's'
  | 't'
  | 'u'
  | 'v'
  | 'w'
  | 'x'
  | 'y'
  | 'z'
  | 'A'
  | 'B'
  | 'C'
  | 'D'
  | 'E'
  | 'F'
  | 'G'
  | 'H'
  | 'I'
  | 'J'
  | 'K'
  | 'L'
  | 'M'
  | 'N'
  | 'O'
  | 'P'
  | 'Q'
  | 'R'
  | 'S'
  | 'T'
  | 'U'
  | 'V'
  | 'W'
  | 'X'
  | 'Y'
  | 'Z'
  | '!'
  | '"'
  | '#'
  | '$'
  | '%'
  | '&'
  | "'"
  | '('
  | ')'
  | '*'
  | '+'
  | ','
  | '-'
  | '.'
  | '/'
  | ':'
  | ';'
  | '<'
  | '='
  | '>'
  | '?'
  | '@'
  | '['
  | '\\'
  | ']'
  | '^'
  | '_'
  | '`'
  | '{'
  | '|'
  | '}'
  | '~ ';
export type ANDROID_KEY =
  | 'home'
  | 'back'
  | 'call'
  | 'endcall'
  | '0'
  | '1'
  | '2'
  | '3'
  | '4'
  | '5'
  | '6'
  | '7'
  | '8'
  | '9'
  | 'star'
  | 'pound'
  | 'dpad_up'
  | 'dpad_down'
  | 'dpad_left'
  | 'dpad_right'
  | 'dpad_center'
  | 'volume_up'
  | 'volume_down'
  | 'power'
  | 'camera'
  | 'clear'
  | 'a'
  | 'b'
  | 'c'
  | 'd'
  | 'e'
  | 'f'
  | 'g'
  | 'h'
  | 'i'
  | 'j'
  | 'k'
  | 'l'
  | 'm'
  | 'n'
  | 'o'
  | 'p'
  | 'q'
  | 'r'
  | 's'
  | 't'
  | 'u'
  | 'v'
  | 'w'
  | 'x'
  | 'y'
  | 'z'
  | 'comma'
  | 'period'
  | 'alt_left'
  | 'alt_right'
  | 'shift_left'
  | 'shift_right'
  | 'tab'
  | 'space'
  | 'sym'
  | 'explorer'
  | 'envelope'
  | 'enter'
  | 'del'
  | 'grave'
  | 'minus'
  | 'equals'
  | 'left_bracket'
  | 'right_bracket'
  | 'backslash'
  | 'semicolon'
  | 'apostrophe'
  | 'slash'
  | 'at'
  | 'num'
  | 'headsethook'
  | 'focus'
  | 'plus'
  | 'menu'
  | 'notification'
  | 'search'
  | 'media_play_pause'
  | 'media_stop'
  | 'media_next'
  | 'media_previous'
  | 'media_rewind'
  | 'media_fast_forward'
  | 'mute'
  | 'page_up'
  | 'page_down'
  | 'switch_charset'
  | 'escape'
  | 'forward_del'
  | 'ctrl_left'
  | 'ctrl_right'
  | 'caps_lock'
  | 'scroll_lock'
  | 'function'
  | 'break'
  | 'move_home'
  | 'move_end'
  | 'insert'
  | 'forward'
  | 'media_play'
  | 'media_pause'
  | 'media_close'
  | 'media_eject'
  | 'media_record'
  | 'f1'
  | 'f2'
  | 'f3'
  | 'f4'
  | 'f5'
  | 'f6'
  | 'f7'
  | 'f8'
  | 'f9'
  | 'f10'
  | 'f11'
  | 'f12'
  | 'num_lock'
  | 'numpad_0'
  | 'numpad_1'
  | 'numpad_2'
  | 'numpad_3'
  | 'numpad_4'
  | 'numpad_5'
  | 'numpad_6'
  | 'numpad_7'
  | 'numpad_8'
  | 'numpad_9'
  | 'numpad_divide'
  | 'numpad_multiply'
  | 'numpad_subtract'
  | 'numpad_add'
  | 'numpad_dot'
  | 'numpad_comma'
  | 'numpad_enter'
  | 'numpad_equals'
  | 'numpad_left_paren'
  | 'numpad_right_paren'
  | 'volume_mute'
  | 'info'
  | 'channel_up'
  | 'channel_down'
  | 'zoom_in'
  | 'zoom_out'
  | 'window'
  | 'guide'
  | 'bookmark'
  | 'captions'
  | 'settings'
  | 'app_switch'
  | 'language_switch'
  | 'contacts'
  | 'calendar'
  | 'music'
  | 'calculator'
  | 'assist'
  | 'brightness_down'
  | 'brightness_up'
  | 'media_audio_track'
  | 'sleep'
  | 'wakeup'
  | 'pairing'
  | 'media_top_menu'
  | 'last_channel'
  | 'tv_data_service'
  | 'voice_assist'
  | 'help'
  | 'navigate_previous'
  | 'navigate_next'
  | 'navigate_in'
  | 'navigate_out'
  | 'dpad_up_left'
  | 'dpad_down_left'
  | 'dpad_up_right'
  | 'dpad_down_right'
  | 'media_skip_forward'
  | 'media_skip_backward'
  | 'media_step_forward'
  | 'media_step_backward'
  | 'soft_sleep'
  | 'cut'
  | 'copy'
  | 'paste'
  | 'all_apps'
  | 'refresh';
export type MODIFIER_KEY =
  | 'command'
  | 'alt'
  | 'control'
  | 'shift'
  | 'right_shift';
export type COLOR =
  | 'black'
  | 'white'
  | 'red'
  | 'green'
  | 'yellow green'
  | 'orange'
  | 'yellow'
  | 'purple'
  | 'pink'
  | 'gray'
  | 'lime green'
  | 'royal blue';
export type PC_AND_MODIFIER_KEY =
  | 'command'
  | 'alt'
  | 'control'
  | 'shift'
  | 'right_shift'
  | 'backspace'
  | 'delete'
  | 'enter'
  | 'tab'
  | 'escape'
  | 'up'
  | 'down'
  | 'right'
  | 'left'
  | 'home'
  | 'end'
  | 'pageup'
  | 'pagedown'
  | 'f1'
  | 'f2'
  | 'f3'
  | 'f4'
  | 'f5'
  | 'f6'
  | 'f7'
  | 'f8'
  | 'f9'
  | 'f10'
  | 'f11'
  | 'f12'
  | 'space'
  | '0'
  | '1'
  | '2'
  | '3'
  | '4'
  | '5'
  | '6'
  | '7'
  | '8'
  | '9'
  | 'a'
  | 'b'
  | 'c'
  | 'd'
  | 'e'
  | 'f'
  | 'g'
  | 'h'
  | 'i'
  | 'j'
  | 'k'
  | 'l'
  | 'm'
  | 'n'
  | 'o'
  | 'p'
  | 'q'
  | 'r'
  | 's'
  | 't'
  | 'u'
  | 'v'
  | 'w'
  | 'x'
  | 'y'
  | 'z'
  | 'A'
  | 'B'
  | 'C'
  | 'D'
  | 'E'
  | 'F'
  | 'G'
  | 'H'
  | 'I'
  | 'J'
  | 'K'
  | 'L'
  | 'M'
  | 'N'
  | 'O'
  | 'P'
  | 'Q'
  | 'R'
  | 'S'
  | 'T'
  | 'U'
  | 'V'
  | 'W'
  | 'X'
  | 'Y'
  | 'Z'
  | '!'
  | '"'
  | '#'
  | '$'
  | '%'
  | '&'
  | "'"
  | '('
  | ')'
  | '*'
  | '+'
  | ','
  | '-'
  | '.'
  | '/'
  | ':'
  | ';'
  | '<'
  | '='
  | '>'
  | '?'
  | '@'
  | '['
  | '\\'
  | ']'
  | '^'
  | '_'
  | '`'
  | '{'
  | '|'
  | '}'
  | '~ ';

export interface CommandExecutorContext {
  customElementsJson: CustomElementJson[];
  aiElementNames: string[];
}

abstract class FluentBase {
  constructor(protected prev?: FluentBase) {}

  protected _textStr = '';

  protected _params = new Map<string, unknown>();

  protected static addParams(
    paramsList: Map<string, unknown[]>,
    params: Map<string, unknown>,
  ): Map<string, unknown[]> {
    params.forEach((value: unknown, key: string) => {
      if (!paramsList.has(key)) {
        paramsList.set(key, []);
      }
      paramsList.set(key, [value, ...(paramsList.get(key) as unknown[])]);
    });
    return paramsList;
  }

  protected fluentCommandStringBuilder(
    currentInstruction = '',
    paramsList: Map<string, unknown[]> = new Map<string, unknown[]>(),
  ): Promise<void> {
    const newCurrentInstruction = `${this.textStr} ${currentInstruction}`;
    const newParamsList = FluentBase.addParams(paramsList, this._params);
    if (this instanceof FluentCommand) {
      const fluentCommand = this as FluentCommand;
      const customElements = newParamsList.has('customElement')
        ? (newParamsList.get('customElement') as CustomElementJson[])
        : [];
      const aiElementNames = newParamsList.has('aiElementName')
        ? (newParamsList.get('aiElementName') as string[])
        : [];
      return fluentCommand.fluentCommandExecutor(newCurrentInstruction.trim(), {
        customElementsJson: customElements,
        aiElementNames,
      });
    }
    if (!this.prev) {
      throw new Error('Prev element not defined');
    }
    return this.prev.fluentCommandStringBuilder(
      newCurrentInstruction,
      newParamsList,
    );
  }

  protected getterStringBuilder(
    currentInstruction = '',
    paramsList: Map<string, unknown[]> = new Map<string, unknown[]>(),
  ): Promise<DetectedElement[]> {
    const newCurrentInstruction = `${this.textStr} ${currentInstruction}`;
    const newParamsList = FluentBase.addParams(paramsList, this._params);
    if (this instanceof Getter) {
      const getter = this as Getter;
      const customElements = newParamsList.has('customElement')
        ? (newParamsList.get('customElement') as CustomElementJson[])
        : [];
      const aiElementNames = newParamsList.has('aiElementName')
        ? (newParamsList.get('aiElementName') as string[])
        : [];
      return getter.getterExecutor(newCurrentInstruction.trim(), {
        customElementsJson: customElements,
        aiElementNames,
      });
    }
    if (!this.prev) {
      throw new Error('Prev element not defined');
    }
    return this.prev.getterStringBuilder(newCurrentInstruction, newParamsList);
  }

  protected get textStr() {
    return this._textStr;
  }

  protected get params() {
    return this._params;
  }
}

export interface Executable {
  exec(): Promise<void>;
}

export class Exec extends FluentBase implements Executable {
  exec(): Promise<void> {
    return this.fluentCommandStringBuilder();
  }
}

// Filters

export class FluentFilters extends FluentBase {
  /**
   * Filters for a UI element 'other element'.
   *
   * @return {FluentFiltersOrRelations}
   */
  otherElement(): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'other';
    this._textStr += ' element';

    return new FluentFiltersOrRelations(this);
  }

  /**
   * Filters for a UI element 'switch'.
   *
   * @return {FluentFiltersOrRelations}
   */
  switch(): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'switch';

    return new FluentFiltersOrRelations(this);
  }

  /**
   * Filters for a UI element 'container'.
   *
   * @return {FluentFiltersOrRelations}
   */
  container(): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'container';

    return new FluentFiltersOrRelations(this);
  }

  /**
   * Filters for a UI element 'checkbox'.
   *
   * @return {FluentFiltersOrRelations}
   */
  checkbox(): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'checkbox';

    return new FluentFiltersOrRelations(this);
  }

  /**
   * Filters for any UI element on the screen.
   *
   * **Examples:**
   * ```typescript
   * await aui.moveMouseTo().element().exec()
   * ```
   *
   * @return {FluentFiltersOrRelations}
   */
  element(): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'element';

    return new FluentFiltersOrRelations(this);
  }

  /**
   * Filters special elements defined over a specifically trained custom element descriptor.
   *
   * Custom element descriptors are trained on your elements that were not detected with our
   * default models. Please contact us for further details on how to do this. We are working on
   * a solution to provide this in our User Portal.
   *
   * In the example below circle refers to a circle shaped icon with specific properties.
   *
   * **Examples:**
   * ```typescript
   * await aui.moveMouseTo().element().special("circle").exec()
   * ```
   *
   * @param {string} text - A text to be matched.
   *
   * @return {FluentFiltersOrRelations}
   */
  special(text: string): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'special';
    this._textStr += ` ${Separators.STRING}${text}${Separators.STRING}`;

    return new FluentFiltersOrRelations(this);
  }

  /**
   * Filters for a UI element 'button'.
   *
   * **Examples:**
   * ```typescript
   * await aui.click().button().contains().text().withText('Google Search').exec()
   * ```
   *
   * ![](https://docs.askui.com/img/gif/button.gif)
   *
   * @return {FluentFiltersOrRelations}
   */
  button(): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'button';

    return new FluentFiltersOrRelations(this);
  }

  /**
   *
   * @param {number} index - element index
   *
   * @return {FluentFiltersOrRelations}
   */
  row(index: number): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'row';
    this._textStr += ` ${index}`;

    return new FluentFiltersOrRelations(this);
  }

  /**
   *
   * @param {number} index - element index
   *
   * @return {FluentFiltersOrRelations}
   */
  column(index: number): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'column';
    this._textStr += ` ${index}`;

    return new FluentFiltersOrRelations(this);
  }

  /**
   *
   * @param {number} row_index - row index
   * @param {number} column_index - column index
   *
   * @return {FluentFiltersOrRelations}
   */
  cell(row_index: number, column_index: number): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'cell';
    this._textStr += ' row';
    this._textStr += ` ${row_index}`;
    this._textStr += ' column';
    this._textStr += ` ${column_index}`;

    return new FluentFiltersOrRelations(this);
  }

  /**
   * Filters for a UI element 'table'.
   *
   * @return {FluentFiltersOrRelations}
   */
  table(): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'table';

    return new FluentFiltersOrRelations(this);
  }

  /**
   * Filters for an UI element 'text'.
   *
   * Takes an optional parameter to filter for a specific text.
   * See the examples below.
   *
   * See also the filters `withTextRegex()` and `withExactText()`
   *
   * **Examples:**
   * ```typescript
   * await aui.click().text().exec();
   * await aui.click().text('Username').exec();
   *
   * // Matching with an exact text
   * await aui.click().text().withExactText('Username').exec();
   *
   * // Matching with a regex
   * await aui.click().text().withTextRegex('\b[Ss]\w+').exec();
   * ```
   *
   * @param {string} [text] - A text to be matched.
   *
   * @return {FluentFiltersOrRelations}
   */
  text(text?: string): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'text';
    if (text !== undefined) {
      this._textStr += ` ${Separators.STRING}${text}${Separators.STRING}`;
    }

    return new FluentFiltersOrRelations(this);
  }

  /**
   * Filters for a UI element 'icon'.
   *
   * You can combine it with the element-description 'withText()' to look for a specific icon.
   *
   * **Examples:**
   * ```typescript
   * icon().withText('plus')
   * ```
   *
   * ![](https://docs.askui.com/img/gif/icon.gif)
   *
   * **Note:** This is an alpha feature. The prediction of the icon name is sometimes unstable. Use custom elements as an alternative.
   *
   * @return {FluentFiltersOrRelations}
   */
  icon(): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'icon';

    return new FluentFiltersOrRelations(this);
  }

  /**
   * Filters for a 'custom element', that is a UI element that is defined by providing an image and other parameters such as degree of rotation. It allows filtering for a UI element based on an image instead of using text or element descriptions like `button().withText('Submit')` in `await aui.click().button().withText('Submit').exec()`.
   *
   * See the tutorial - [Custom Element](https://docs.askui.com/docs/general/Element%20Selection/custom-elements) for more details.
   *
   * **Example**
   * ```typescript
   * await aui
   *     .click()
   *     .customElement({
   *         customImage: './logo.png', // required
   *         name: 'myLogo', // optional
   *         threshold: 0.5, // optional, defaults to 0.5
   *         stopThreshold: 0.9, // optional, defaults to 0.9
   *         rotationDegreePerStep: 0, // optional, defaults to 0
   *         imageCompareFormat: 'grayscale', // optional, defaults to 'grayscale'
   *         // mask:{x:0, y:0}[] // optional, a polygon to match only a certain area of the custom element
   *     })
   *     .exec();
   * ```
   *
   * **Arguments**
   *
   * - **customImage** (*`string`, required*):
   *     - A cropped image in the form of a base64 string or file path.
   * - **name** (*`string`, optional*):
   *     - A unique name that can be used for filtering for the custom element. If not given, any text inside the custom image will be detected via OCR.
   * - **threshold** (*`number`, optional*):
   *     - A threshold for how much a UI element needs to be similar to the custom element as defined by the image. Takes values between `0.0` (== all elements are recognized as the custom element which is probably not what you want) and `1.0` (== elements need to look exactly like the `customImage` which is unlikely to be achieved as even minor differences count). Defaults to `0.5`.
   * - **stopThreshold** (*`number`, optional*):
   *     - A threshold for when to stop searching for UI elements similar to the custom element. As soon as UI elements have been found that are at least as similar as the `stopThreshold`, the search is going to stop. After that elements are filtered using the `threshold`. Because of that the `stopThreshold` should be greater than or equal to `threshold`. It is primarily to be used as a speed improvement (by lowering the value). Takes values between `0.0` and `1.0`. Defaults to `0.9`.
   * - **rotationDegreePerStep** (*`number`, optional*):
   *     - Step size in rotation degree. Rotates the custom image by this step size until 360° is exceeded. The range is from `0` to `360`. Defaults to `0`.
   * - **imageCompareFormat** (*`'RGB' | 'grayscale' | 'edges'`, optional*):
   *     - The color compare style. `'edges'` compares only edges, `'greyscale'` compares the brightness of each pixel whereas `'RGB'` compares all three colors (red, green, blue). Defaults to `'grayscale'`.
   *
   *
   * @param {CustomElementJson} customElement - The custom element to filter for.
   *
   * @return {FluentFiltersOrRelations}
   */
  customElement(customElement: CustomElementJson): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'custom';
    this._textStr += ' element';

    this._params.set('customElement', customElement);
    return new FluentFiltersOrRelations(this);
  }

  /**
   * Detects an AI Element created with the [snipping workflow](https://docs.askui.com/docs/general/Components/aielement#snipping-workflow).
   *
   * **Examples:**
   *
   * ```typescript
   * await aui.click().aiElement('askui-logo').exec();
   * ```
   *
   * @param {string} aiElementName - Name of the AI Element.
   *
   * @return {FluentFiltersOrRelations}
   */
  aiElement(aiElementName: string): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'ai';
    this._textStr += ' element';
    this._textStr += ' with';
    this._textStr += ' name';
    this._textStr += ` ${Separators.STRING}${aiElementName}${Separators.STRING}`;

    this._params.set('aiElementName', aiElementName);
    return new FluentFiltersOrRelations(this);
  }

  /**
   * Filters for a UI element 'image'.
   *
   * **Examples:**
   * ```typescript
   * // Works if there is only one image visible on the screen
   * await aui.click().image().exec();
   *
   * // Works if you have an image with
   * // a text below
   * await aui.click().image().above().text().withText('Automating WebGL').exec();
   * ```
   *
   * ![](https://docs.askui.com/img/gif/image.gif)
   *
   *
   *
   * @return {FluentFiltersOrRelations}
   */
  image(): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'image';

    return new FluentFiltersOrRelations(this);
  }

  /**
   * Filters for a UI element 'textfield'.
   *
   * **Examples:**
   * ```typescript
   * // Works if there is only one textfield visible on the screen
   * await aui.typeIn('Oh yeah').textfield().exec();
   *
   * // Works if you have a labeled textfield
   * // Label is above the textfield
   * await aui.typeIn('Oh yeah').textfield().below().text().withText('E-Mail Address').exec();
   * ```
   *
   * ![](https://docs.askui.com/img/gif/textfield.gif)
   *
   *
   *
   * @return {FluentFiltersOrRelations}
   */
  textfield(): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'textfield';

    return new FluentFiltersOrRelations(this);
  }

  /**
   * Filters for similar -- meaning >70% similar -- text.
   *
   * Takes an optional parameter to specify the similarity. Usually you need the optional parameter for long texts you want to match precisely.
   *
   * _We use [RapidFuzz](https://maxbachmann.github.io/RapidFuzz/Usage/fuzz.html#ratio) which calculates the similarity like this:_
   *
   * `1 - (distance / (lengthString1 + lengthString2))`
   *
   * **Examples:**
   * ```typescript
   * 'text' === withText('text') => true
   * 'test' === withText('text') => true
   * 'Test' === withText('text') => true
   * 'Text' === withText('text') => true
   * 'TEXT' === withText('text') => true
   * 'texst' === withText('text') => true
   * 'texts' === withText('text') => true
   *
   * // usually false
   * 'atebxtc' === withText('text') => false
   * 'other' === withText('text') => false
   *
   * // optional parameter: similarity_score
   * '978-0-201-00650-6' == withText("978-0-201-00", 90) => false with 82.76 < 90 similarity
   * '978-0-201-00650-6' == withText("978-0-201-00650", 90) => true with 93.75 > 90 similarity
   * ```
   * ![](https://docs.askui.com/img/gif/withText.gif)
   *
   * @param {string} text - A text to be matched.
   * @param {number} [similarityScore=70] - Similarity score minimum value, it should be between `0` and `100`.
   *
   * @return {FluentFiltersOrRelations}
   */
  withText(
    text: string,
    similarityScore = 70,
  ): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'with';
    this._textStr += ' text';
    this._textStr += ` ${Separators.STRING}${text}${Separators.STRING}`;
    if (similarityScore !== undefined) {
      this._textStr += ` that matches to ${similarityScore} %`;
    }

    return new FluentFiltersOrRelations(this);
  }

  /**
   * Filters for texts, which match the regex pattern.
   *
   * **Examples:**
   *
   * ```typescript
   * 'The rain in Spain' === withTextRegex('\b[Ss]\w+') => true
   * 'The rain in Portugal' === withTextRegex('\b[Ss]\w+') => false
   * 'The rain in switzerland' === withTextRegex('\b[Ss]\w+') => true
   *
   * await aui.get().text().withTextRegex('\b[Ss]\w+').exec()
   * ```
   *
   * ![](https://docs.askui.com/img/gif/withTextRegex.gif)
   *
   *
   *
   * @param {string} regex_pattern - A regex pattern
   *
   * @return {FluentFiltersOrRelations}
   */
  withTextRegex(regex_pattern: string): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'match';
    this._textStr += ' regex';
    this._textStr += ' pattern';
    this._textStr += ` ${Separators.STRING}${regex_pattern}${Separators.STRING}`;

    return new FluentFiltersOrRelations(this);
  }

  /**
   * Filters for equal text.
   *
   * **Note:** This should be only used in cases where the similarity
   *  comparison of {@link FluentFilters.withText()} allows not for
   *  specific enough filtering (too many elements).
   *
   * **Examples:**
   * ```typescript
   * 'text' === withExactText('text') => true
   * 'test' === withExactText('text') => false
   * 'other' === withExactText('text') => false
   *
   * await aui.moveMouseTo().text().withExactText('Password').exec()
   * ```
   *
   * ![](https://docs.askui.com/img/gif/withExactText.gif)
   *
   *
   *
   * @param {string} text - A text to be matched.
   *
   * @return {FluentFiltersOrRelations}
   */
  withExactText(text: string): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'equals';
    this._textStr += ' text';
    this._textStr += ` ${Separators.STRING}${text}${Separators.STRING}`;

    return new FluentFiltersOrRelations(this);
  }

  /**
   * Filters for text containing the text provided as an argument.
   *
   * **Examples:**
   * ```typescript
   * 'This is a text' === containsText('text') => true
   * 'This is a text' === containsText('other text') => false
   * 'This is a text' === containsText('other') => false
   * ```
   * ![](https://docs.askui.com/img/gif/containsText.gif)
   *
   * @param {string} text - A text to be matched.
   *
   * @return {FluentFiltersOrRelations}
   */
  containsText(text: string): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'contain';
    this._textStr += ' text';
    this._textStr += ` ${Separators.STRING}${text}${Separators.STRING}`;

    return new FluentFiltersOrRelations(this);
  }

  /**
   * Filters elements based on a textual description.
   *
   * **What Should I Write as Matching Text**
   *
   * The text description inside the `matching()` should describe the element visually.
   * It understands color, some famous company/product names, general descriptions.
   *
   * **Important: _Matching only returns the best matching element when you use it with `get()`_**
   *
   * A bit of playing around to find a matching description is sometimes needed:
   * For example, `puzzle piece` can fail while `an icon showing a puzzle piece` might work.
   * Generally, the more detail the better.
   *
   * We also recommend to not restrict the type of element by using the general selector `element()` as shown in the examples below.
   *
   * **Examples:**
   * ```typescript
   * // Select the black sneaker from a bunch of sneakers
   * await aui.click().element().matching('a black sneaker shoe').exec();
   *
   * // Select an image that has text in it
   * await aui.click().element().matching('has Burger King in it').exec();
   * await aui.click().element().matching('has adidas in it').exec();
   *
   * // Target a logo/image by describing it
   * await aui.click().element().matching('a mask on purple background and a firefox logo').exec();
   * await aui.click().element().matching('logo looking like an apple with one bite bitten off').exec();
   * await aui.click().element().matching('logo looking like a seashell').exec();
   * ```
   *
   * @param {string} text - A description of the target element.
   *
   * @return {FluentFiltersOrRelations}
   */
  matching(text: string): FluentFiltersOrRelations {
    this._textStr = '';

    this._textStr += 'matching';
    this._textStr += ` ${Separators.STRING}${text}${Separators.STRING}`;

    return new FluentFiltersOrRelations(this);
  }
}

// Relations

export class FluentFiltersOrRelations extends FluentFilters {
  /**
   * Logic or operator
   *
   * **Examples:**
   * ```text
   * scene 1
   * --------------  ---------------
   * |  button    |  |  icon       |
   * --------------  ---------------
   *
   * scene 2
   * --------------  ---------------
   * |  button    |  |  text       |
   * --------------  ---------------
   *
   * ```
   * In case, that your reference element can have multiple values, in the following example, the element right of the button can be either icon or text.
   * You can use **the `or()` relation**, so your instruction is valid for both scenes
   * ```typescript
   * const button = await aui.get().button().rightOf().icon().or().text().exec();
   * console.log(button);
   * ```
   * Returns the same button for both cases
   * ```text
   *  console output: [
   *   DetectedElement {
   *      name: 'BUTTON',
   *      text: 'button',
   *      bndbox: BoundingBox {
   *         xmin: 900,
   *         ymin: 910,
   *         xmax: 920,
   *         ymax: 930
   *      }
   *   }
   *  ]
   * ```
   *
   * @return {FluentFilters}
   */
  or(): FluentFilters {
    this._textStr = '';

    this._textStr += 'or';

    return new FluentFilters(this);
  }

  /**
   * Logic and operator
   *
   * **Examples:**
   * ```text
   * example scene:
   *  ---------------   ----------------
   *  |  icon user  |   |  icon search |
   *  ---------------   ----------------
   * ```
   * ```typescript
   * const icons = await aui.get().icon().exec();
   * console.log(icons);
   * ```
   * Using only the element-description icon, the get will return both icons
   * ```text
   * console output: [
   *   DetectedElement {
   *      name: 'ICON',
   *      text: 'user',
   *      bndbox: BoundingBox {
   *         xmin: 1000,
   *         ymin: 1010,
   *         xmax: 1020,
   *         ymax: 1030
   *      }
   *   },
   *   DetectedElement {
   *      name: 'ICON',
   *      text: 'search',
   *      bndbox: BoundingBox {
   *         xmin: 900,
   *         ymin: 910,
   *         xmax: 920,
   *         ymax: 930
   *      }
   *   }
   *  ]
   * ```
   * You can combine element-descriptions with **the `and()` relation** and specify exactly which icon you want.
   * ```typescript
   * const icons = await aui.get().icon().and().withText('user').exec()
   * console.log(icons)
   * ```
   * The get returns only the user icon although both elements are icons.
   * ```text
   *  console output: [
   *   DetectedElement {
   *      name: 'ICON',
   *      text: 'user',
   *      bndbox: BoundingBox {
   *         xmin: 900,
   *         ymin: 910,
   *         xmax: 920,
   *         ymax: 930
   *      }
   *   }
   *  ]
   * ```
   *
   * @return {FluentFilters}
   */
  and(): FluentFilters {
    this._textStr = '';

    this._textStr += 'and';

    return new FluentFilters(this);
  }

  /**
   * Filters for an element inside another element.
   *
   * **Examples:**
   * ```typescript
   * --------------------
   * |     outerEl      |
   * |  --------------  |
   * |  |  innerEl   |  |
   * |  --------------  |
   * |                  |
   * --------------------
   *
   * // Returns innerEl because innerEl is inside outerEl
   * ...innerEl().in().outerEl()
   * // Returns nothing because innerEl is not inside outerEl
   * ...outerEl().in().innerEl()
   * ```
   * ![](https://docs.askui.com/img/gif/in.gif)
   *
   * @return {FluentFilters}
   */
  in(): FluentFilters {
    this._textStr = '';

    this._textStr += 'in';

    return new FluentFilters(this);
  }

  /**
   * Filters for an element right of another element.
   *
   * Takes an optional parameter `index` to select the nth element (defaults to `0`).
   *
   * Takes an optional parameter `intersection_area` to specify which elements right of the other element are filtered for based on their vertical position (y-coordinates of bounding box):
   * - `"element_center_line"` - considered right of the other element if element's bounding box intersects with a horizontal line passing through the center of the other element
   * - `"element_edge_area"` - considered right of the other element if element's bounding box intersects with an area between the top and the bottom edge of the other element
   * - `"display_edge_area"` - considered right of the other element no matter where it is placed vertically on the screen (y-axis)
   *
   * **Examples:**
   * ```typescript
   * ---------- ---------                     ---------
   * | button | | text0 |                     | text3 |
   * ---------- --------- ---------           ---------
   *                      | text1 | ---------
   *                      --------- | text2 |
   *                                ---------
   *
   * // General explanation for element_center_line
   * // This will find text0 and text3
   * ...text().rightOf(..., 'element_center_line').button()
   *
   * // General explanation for element_edge_area
   * // This will find text0, text1 and text3
   * ...text().rightOf(..., 'element_edge_area').button()
   *
   * // General explanation and display_edge_area
   * // This will find text0, text1, text2 and text3
   * ...text().rightOf(..., 'display_edge_area').button()
   *
   * // More examples:
   * // Returns text0 because it is the first element rightOf button
   * ...text().rightOf().button()
   * ...text().rightOf(0).button()
   * ...text().rightOf(0, 'element_edge_area').button()
   *
   * // Returns text3 because it is the second text touched by the
   * // horizontal line from the center of button
   * // Notice: text1 is not touched!
   * ...text().rightOf(1, 'element_center_line').button()
   *
   * // Returns text3 because it is the third text touched by the
   * // vertical area rightOf the y-axis of button
   * // Notice: text2 is not touched!
   * ...text().rightOf(2, 'element_edge_area').button()
   *
   * // Returns text2 because it is the third element rightOf button
   * ...text().rightOf(2, 'display_edge_area').button()
   *
   * // Returns no element because button is rightOf the texts
   * ...button().rightOf().text()
   * ```
   * ![](https://docs.askui.com/img/gif/rightOf.gif)
   *
   * @param {number} [index=0] - Index of element to filter for going into the direction specified. Defaults to `0` which is the first element (zero-indexed) found in that direction.
   * @param {INTERSECTION_AREA} [intersection_area="element_edge_area"] - Intersecting with either `"element_center_line"`, `"element_edge_area"` or `"display_edge_area"`. Defaults to `"element_edge_area"`.
   *
   * @return {FluentFilters}
   */
  rightOf(
    index = 0,
    intersection_area: INTERSECTION_AREA = 'element_edge_area',
  ): FluentFilters {
    this._textStr = '';

    if (index !== undefined) {
      this._textStr += `index ${index}`;
    }
    this._textStr += ' right';
    this._textStr += ' of';
    if (intersection_area !== undefined) {
      this._textStr += ` intersection_area ${intersection_area}`;
    }

    return new FluentFilters(this);
  }

  /**
   * Filters for an element left of another element.
   *
   * Takes an optional parameter `index` to select the nth element (defaults to `0`).
   *
   * Takes an optional parameter `intersection_area` to specify which elements left of the other element are filtered for based on their vertical position (y-coordinates of bounding box):
   * - `"element_center_line"` - considered left of the other element if element's bounding box intersects with a horizontal line passing through the center of the other element
   * - `"element_edge_area"` - considered left of the other element if element's bounding box intersects with an area between the top and the bottom edge of the other element
   * - `"display_edge_area"` - considered left of the other element no matter where it is placed vertically on the screen (y-axis)
   *
   * **Examples:**
   * ```typescript
   * ---------                   --------- ----------
   * | text3 |                   | text0 | | button |
   * ---------         --------- --------- ----------
   *         --------- | text1 |
   *         | text2 | ---------
   *         ---------
   *
   * // General explanation for element_center_line
   * // This will find text0 and text3
   * ...text().leftOf(..., 'element_center_line').button()
   *
   * // General explanation for element_edge_area
   * // This will find text0, text1 and text3
   * ...text().leftOf(..., 'element_edge_area').button()
   *
   * // General explanation and display_edge_area
   * // This will find text0, text1, text2 and text3
   * ...text().leftOf(..., 'display_edge_area').button()
   *
   * // More examples:
   * // Returns text0 because it is the first element leftOf button
   * ...text().leftOf().button()
   * ...text().leftOf(0).button()
   * ...text().leftOf(0, 'element_edge_area').button()
   *
   * // Returns text3 because it is the second text touched by the
   * // horizontal line from the center of button
   * // Notice: text1 is not touched!
   * ...text().leftOf(1, 'element_center_line').button()
   *
   * // Returns text3 because it is the third text touched by the
   * // vertical area leftOf the y-axis of button
   * // Notice: text2 is not touched!
   * ...text().leftOf(2, 'element_edge_area').button()
   *
   * // Returns text2 because it is the third element leftOf button
   * ...text().leftOf(2, 'display_edge_area').button()
   *
   * // Returns no element because button is rightOf the texts
   * ...button().leftOf().text()
   * ```
   * ![](https://docs.askui.com/img/gif/leftOf.gif)
   *
   * @param {number} [index=0] - Index of element to filter for going into the direction specified. Defaults to `0` which is the first element (zero-indexed) found in that direction.
   * @param {INTERSECTION_AREA} [intersection_area="element_edge_area"] - Intersecting with either `"element_center_line"`, `"element_edge_area"` or `"display_edge_area"`. Defaults to `"element_edge_area"`.
   *
   * @return {FluentFilters}
   */
  leftOf(
    index = 0,
    intersection_area: INTERSECTION_AREA = 'element_edge_area',
  ): FluentFilters {
    this._textStr = '';

    if (index !== undefined) {
      this._textStr += `index ${index}`;
    }
    this._textStr += ' left';
    this._textStr += ' of';
    if (intersection_area !== undefined) {
      this._textStr += ` intersection_area ${intersection_area}`;
    }

    return new FluentFilters(this);
  }

  /**
   * Filters for an element below another element.
   *
   * Takes an optional parameter `index` to select the nth element (defaults to `0`).
   *
   * Takes an optional parameter `intersection_area` to specify which elements below of the other element are filtered for based on their horizontal position (y-coordinates of bounding box):
   * - `"element_center_line"` - considered below of the other element if element's bounding box intersects with a vertical line passing through the center of the other element
   * - `"element_edge_area"` - considered below of the other element if element's bounding box intersects with an area between the left and the right edge of the other element
   * - `"display_edge_area"` - considered below of the other element no matter where it is placed horizontally on the screen (y-axis)
   *
   * **Examples:**
   * ```typescript
   * ------------
   * |   text   |
   * ------------
   * ------------
   * |  button0 |
   * ------------
   *          -----------
   *          | button1 |
   *          -----------
   *             -----------
   *             | button2 |
   *             -----------
   * ------------
   * |  button3 |
   * ------------
   *
   * // General explanation for element_center_line
   * // This will find button0 and button3
   * ...button().below(..., 'element_center_line').text()
   *
   * // General explanation for element_edge_area
   * // This will find button0, button1 and button3
   * ...button().below(..., 'element_edge_area').text()
   *
   * // General explanation and display_edge_area
   * // This will find button0, button1, button2 and button3
   * ...button().below(..., 'display_edge_area').text()
   *
   * // More examples:
   * // Returns button0 because button0 is the first button below text
   * ...button().below().text()
   * ...button().below(0).text()
   * ...button().below(0, 'element_edge_area').text()
   *
   * // Returns button3 because it is the second button touched by the
   * // vertical line from the center of text
   * // Notice: button1 is not touched
   * ...button().below(1, 'element_center_line').text()
   *
   * // Returns button3 because it is the third button touched by the
   * // vertical area below the x-axis of text
   * // Notice: button2 is not touched!
   * ...button().below(2, 'element_edge_area').text()
   *
   * // Returns button2 because it is the third element below text
   * ...button().below(2, 'display_edge_area').text()
   *
   * // Returns no element because text is above the buttons
   * ...text().below().button()
   * ```
   * ![](https://docs.askui.com/img/gif/below.gif)
   *
   * @param {number} [index=0] - Index of element to filter for going into the direction specified. Defaults to `0` which is the first element (zero-indexed) found in that direction.
   * @param {INTERSECTION_AREA} [intersection_area="element_edge_area"] - Intersecting with either `"element_center_line"`, `"element_edge_area"` or `"display_edge_area"`. Defaults to `"element_edge_area"`.
   *
   * @return {FluentFilters}
   */
  below(
    index = 0,
    intersection_area: INTERSECTION_AREA = 'element_edge_area',
  ): FluentFilters {
    this._textStr = '';

    if (index !== undefined) {
      this._textStr += `index ${index}`;
    }
    this._textStr += ' below';
    if (intersection_area !== undefined) {
      this._textStr += ` intersection_area ${intersection_area}`;
    }

    return new FluentFilters(this);
  }

  /**
   * Filters for an element above another element.
   *
   * Takes an optional parameter `index` to select the nth element (defaults to `0`).
   *
   * Takes an optional parameter `intersection_area` to specify which elements above of the other element are filtered for based on their horizontal position (y-coordinates of bounding box):
   * - `"element_center_line"` - considered above of the other element if element's bounding box intersects with a vertical line passing through the center of the other element
   * - `"element_edge_area"` - considered above of the other element if element's bounding box intersects with an area between the left and the right edge of the other element
   * - `"display_edge_area"` - considered above of the other element no matter where it is placed horizontally on the screen (y-axis)
   *
   * **Examples:**
   * ```typescript
   * ------------
   * |  text3   |
   * ------------
   *             ------------
   *             |  text2   |
   *             ------------
   *     ------------
   *     |  text1   |
   *     ------------
   * ------------
   * |  text0   |
   * ------------
   * ------------
   * |  button  |
   * ------------
   *
   * // General explanation for element_center_line
   * // This will find text0 and text3
   * ...text().above(..., 'element_center_line').button()
   *
   * // General explanation for element_edge_area
   * // This will find text0, text1 and text3
   * ...text().above(..., 'element_edge_area').button()
   *
   * // General explanation and display_edge_area
   * // This will find text0, text1, text2 and text3
   * ...text().above(..., 'display_edge_area').button()
   *
   * // More examples:
   * // Returns text0 because it is the first element above button
   * ...text().above().button()
   * ...text().above(0).button()
   * ...text().above(0, 'element_edge_area').button()
   *
   * // Returns text3 because it is the second text touched by the
   * // vertical line from the center of button
   * // Notice: text1 is not touched!
   * ...text().above(1, 'element_center_line').button()
   *
   * // Returns text3 because it is the third text touched by the
   * // vertical area above the x-axis of button
   * // Notice: text2 is not touched!
   * ...text().above(2, 'element_edge_area').button()
   *
   * // Returns text2 because it is the third element above button
   * ...text().above(2, 'display_edge_area').button()
   *
   * // Returns no element because button is below the texts
   * ...button().above().text()
   * ```
   * ![](https://docs.askui.com/img/gif/above.gif)
   *
   * @param {number} [index=0] - Index of element to filter for going into the direction specified. Defaults to `0` which is the first element (zero-indexed) found in that direction.
   * @param {INTERSECTION_AREA} [intersection_area="element_edge_area"] - Intersecting with either `"element_center_line"`, `"element_edge_area"` or `"display_edge_area"`. Defaults to `"element_edge_area"`.
   *
   * @return {FluentFilters}
   */
  above(
    index = 0,
    intersection_area: INTERSECTION_AREA = 'element_edge_area',
  ): FluentFilters {
    this._textStr = '';

    if (index !== undefined) {
      this._textStr += `index ${index}`;
    }
    this._textStr += ' above';
    if (intersection_area !== undefined) {
      this._textStr += ` intersection_area ${intersection_area}`;
    }

    return new FluentFilters(this);
  }

  /**
   * Filters for an element nearest to another element.
   *
   * **Examples:**
   * ```typescript
   * --------------
   * |  button 1  |
   * --------------
   * --------------
   * |   text     |
   * --------------
   *
   *
   *
   * --------------
   * |  button 2  |
   * --------------
   *
   * // Returns button 1 because button 1 is nearer to the text than button 2
   * ...button().nearestTo().text()
   * ```
   * ![](https://docs.askui.com/img/gif/nearestTo.gif)
   *
   * @return {FluentFilters}
   */
  nearestTo(): FluentFilters {
    this._textStr = '';

    this._textStr += 'nearest';
    this._textStr += ' to';

    return new FluentFilters(this);
  }

  /**
   * Filters for an element containing another element.
   *
   * **Example:**
   * ```typescript
   * --------------------
   * |     outerEl      |
   * |  --------------  |
   * |  |  innerEl   |  |
   * |  --------------  |
   * |                  |
   * --------------------
   *
   * // Returns outerEl because outerEl contains innerEl
   * ...outerEl().contains().innerEl()
   * //  Returns no element because innerEl contains no outerEl
   * ...innerEl().contains().outerEl()
   * ```
   * ![](https://docs.askui.com/img/gif/contains.gif)
   *
   * @return {FluentFilters}
   */
  contains(): FluentFilters {
    this._textStr = '';

    this._textStr += 'contains';

    return new FluentFilters(this);
  }

  exec(): Promise<void> {
    return this.fluentCommandStringBuilder();
  }
}

// Filters

export class FluentFiltersCondition extends FluentBase {
  /**
   * Filters for a UI element 'other element'.
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  otherElement(): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'other';
    this._textStr += ' element';

    return new FluentFiltersOrRelationsCondition(this);
  }

  /**
   * Filters for a UI element 'switch'.
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  switch(): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'switch';

    return new FluentFiltersOrRelationsCondition(this);
  }

  /**
   * Filters for a UI element 'container'.
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  container(): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'container';

    return new FluentFiltersOrRelationsCondition(this);
  }

  /**
   * Filters for a UI element 'checkbox'.
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  checkbox(): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'checkbox';

    return new FluentFiltersOrRelationsCondition(this);
  }

  /**
   * Filters for any UI element on the screen.
   *
   * **Examples:**
   * ```typescript
   * await aui.moveMouseTo().element().exec()
   * ```
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  element(): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'element';

    return new FluentFiltersOrRelationsCondition(this);
  }

  /**
   * Filters special elements defined over a specifically trained custom element descriptor.
   *
   * Custom element descriptors are trained on your elements that were not detected with our
   * default models. Please contact us for further details on how to do this. We are working on
   * a solution to provide this in our User Portal.
   *
   * In the example below circle refers to a circle shaped icon with specific properties.
   *
   * **Examples:**
   * ```typescript
   * await aui.moveMouseTo().element().special("circle").exec()
   * ```
   *
   * @param {string} text - A text to be matched.
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  special(text: string): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'special';
    this._textStr += ` ${Separators.STRING}${text}${Separators.STRING}`;

    return new FluentFiltersOrRelationsCondition(this);
  }

  /**
   * Filters for a UI element 'button'.
   *
   * **Examples:**
   * ```typescript
   * await aui.click().button().contains().text().withText('Google Search').exec()
   * ```
   *
   * ![](https://docs.askui.com/img/gif/button.gif)
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  button(): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'button';

    return new FluentFiltersOrRelationsCondition(this);
  }

  /**
   *
   * @param {number} index - element index
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  row(index: number): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'row';
    this._textStr += ` ${index}`;

    return new FluentFiltersOrRelationsCondition(this);
  }

  /**
   *
   * @param {number} index - element index
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  column(index: number): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'column';
    this._textStr += ` ${index}`;

    return new FluentFiltersOrRelationsCondition(this);
  }

  /**
   *
   * @param {number} row_index - row index
   * @param {number} column_index - column index
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  cell(
    row_index: number,
    column_index: number,
  ): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'cell';
    this._textStr += ' row';
    this._textStr += ` ${row_index}`;
    this._textStr += ' column';
    this._textStr += ` ${column_index}`;

    return new FluentFiltersOrRelationsCondition(this);
  }

  /**
   * Filters for a UI element 'table'.
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  table(): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'table';

    return new FluentFiltersOrRelationsCondition(this);
  }

  /**
   * Filters for an UI element 'text'.
   *
   * Takes an optional parameter to filter for a specific text.
   * See the examples below.
   *
   * See also the filters `withTextRegex()` and `withExactText()`
   *
   * **Examples:**
   * ```typescript
   * await aui.click().text().exec();
   * await aui.click().text('Username').exec();
   *
   * // Matching with an exact text
   * await aui.click().text().withExactText('Username').exec();
   *
   * // Matching with a regex
   * await aui.click().text().withTextRegex('\b[Ss]\w+').exec();
   * ```
   *
   * @param {string} [text] - A text to be matched.
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  text(text?: string): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'text';
    if (text !== undefined) {
      this._textStr += ` ${Separators.STRING}${text}${Separators.STRING}`;
    }

    return new FluentFiltersOrRelationsCondition(this);
  }

  /**
   * Filters for a UI element 'icon'.
   *
   * You can combine it with the element-description 'withText()' to look for a specific icon.
   *
   * **Examples:**
   * ```typescript
   * icon().withText('plus')
   * ```
   *
   * ![](https://docs.askui.com/img/gif/icon.gif)
   *
   * **Note:** This is an alpha feature. The prediction of the icon name is sometimes unstable. Use custom elements as an alternative.
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  icon(): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'icon';

    return new FluentFiltersOrRelationsCondition(this);
  }

  /**
   * Filters for a 'custom element', that is a UI element that is defined by providing an image and other parameters such as degree of rotation. It allows filtering for a UI element based on an image instead of using text or element descriptions like `button().withText('Submit')` in `await aui.click().button().withText('Submit').exec()`.
   *
   * See the tutorial - [Custom Element](https://docs.askui.com/docs/general/Element%20Selection/custom-elements) for more details.
   *
   * **Example**
   * ```typescript
   * await aui
   *     .click()
   *     .customElement({
   *         customImage: './logo.png', // required
   *         name: 'myLogo', // optional
   *         threshold: 0.5, // optional, defaults to 0.5
   *         stopThreshold: 0.9, // optional, defaults to 0.9
   *         rotationDegreePerStep: 0, // optional, defaults to 0
   *         imageCompareFormat: 'grayscale', // optional, defaults to 'grayscale'
   *         // mask:{x:0, y:0}[] // optional, a polygon to match only a certain area of the custom element
   *     })
   *     .exec();
   * ```
   *
   * **Arguments**
   *
   * - **customImage** (*`string`, required*):
   *     - A cropped image in the form of a base64 string or file path.
   * - **name** (*`string`, optional*):
   *     - A unique name that can be used for filtering for the custom element. If not given, any text inside the custom image will be detected via OCR.
   * - **threshold** (*`number`, optional*):
   *     - A threshold for how much a UI element needs to be similar to the custom element as defined by the image. Takes values between `0.0` (== all elements are recognized as the custom element which is probably not what you want) and `1.0` (== elements need to look exactly like the `customImage` which is unlikely to be achieved as even minor differences count). Defaults to `0.5`.
   * - **stopThreshold** (*`number`, optional*):
   *     - A threshold for when to stop searching for UI elements similar to the custom element. As soon as UI elements have been found that are at least as similar as the `stopThreshold`, the search is going to stop. After that elements are filtered using the `threshold`. Because of that the `stopThreshold` should be greater than or equal to `threshold`. It is primarily to be used as a speed improvement (by lowering the value). Takes values between `0.0` and `1.0`. Defaults to `0.9`.
   * - **rotationDegreePerStep** (*`number`, optional*):
   *     - Step size in rotation degree. Rotates the custom image by this step size until 360° is exceeded. The range is from `0` to `360`. Defaults to `0`.
   * - **imageCompareFormat** (*`'RGB' | 'grayscale' | 'edges'`, optional*):
   *     - The color compare style. `'edges'` compares only edges, `'greyscale'` compares the brightness of each pixel whereas `'RGB'` compares all three colors (red, green, blue). Defaults to `'grayscale'`.
   *
   *
   * @param {CustomElementJson} customElement - The custom element to filter for.
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  customElement(
    customElement: CustomElementJson,
  ): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'custom';
    this._textStr += ' element';

    this._params.set('customElement', customElement);
    return new FluentFiltersOrRelationsCondition(this);
  }

  /**
   * Detects an AI Element created with the [snipping workflow](https://docs.askui.com/docs/general/Components/aielement#snipping-workflow).
   *
   * **Examples:**
   *
   * ```typescript
   * await aui.click().aiElement('askui-logo').exec();
   * ```
   *
   * @param {string} aiElementName - Name of the AI Element.
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  aiElement(aiElementName: string): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'ai';
    this._textStr += ' element';
    this._textStr += ' with';
    this._textStr += ' name';
    this._textStr += ` ${Separators.STRING}${aiElementName}${Separators.STRING}`;

    this._params.set('aiElementName', aiElementName);
    return new FluentFiltersOrRelationsCondition(this);
  }

  /**
   * Filters for a UI element 'image'.
   *
   * **Examples:**
   * ```typescript
   * // Works if there is only one image visible on the screen
   * await aui.click().image().exec();
   *
   * // Works if you have an image with
   * // a text below
   * await aui.click().image().above().text().withText('Automating WebGL').exec();
   * ```
   *
   * ![](https://docs.askui.com/img/gif/image.gif)
   *
   *
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  image(): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'image';

    return new FluentFiltersOrRelationsCondition(this);
  }

  /**
   * Filters for a UI element 'textfield'.
   *
   * **Examples:**
   * ```typescript
   * // Works if there is only one textfield visible on the screen
   * await aui.typeIn('Oh yeah').textfield().exec();
   *
   * // Works if you have a labeled textfield
   * // Label is above the textfield
   * await aui.typeIn('Oh yeah').textfield().below().text().withText('E-Mail Address').exec();
   * ```
   *
   * ![](https://docs.askui.com/img/gif/textfield.gif)
   *
   *
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  textfield(): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'textfield';

    return new FluentFiltersOrRelationsCondition(this);
  }

  /**
   * Filters for similar -- meaning >70% similar -- text.
   *
   * Takes an optional parameter to specify the similarity. Usually you need the optional parameter for long texts you want to match precisely.
   *
   * _We use [RapidFuzz](https://maxbachmann.github.io/RapidFuzz/Usage/fuzz.html#ratio) which calculates the similarity like this:_
   *
   * `1 - (distance / (lengthString1 + lengthString2))`
   *
   * **Examples:**
   * ```typescript
   * 'text' === withText('text') => true
   * 'test' === withText('text') => true
   * 'Test' === withText('text') => true
   * 'Text' === withText('text') => true
   * 'TEXT' === withText('text') => true
   * 'texst' === withText('text') => true
   * 'texts' === withText('text') => true
   *
   * // usually false
   * 'atebxtc' === withText('text') => false
   * 'other' === withText('text') => false
   *
   * // optional parameter: similarity_score
   * '978-0-201-00650-6' == withText("978-0-201-00", 90) => false with 82.76 < 90 similarity
   * '978-0-201-00650-6' == withText("978-0-201-00650", 90) => true with 93.75 > 90 similarity
   * ```
   * ![](https://docs.askui.com/img/gif/withText.gif)
   *
   * @param {string} text - A text to be matched.
   * @param {number} [similarityScore=70] - Similarity score minimum value, it should be between `0` and `100`.
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  withText(
    text: string,
    similarityScore = 70,
  ): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'with';
    this._textStr += ' text';
    this._textStr += ` ${Separators.STRING}${text}${Separators.STRING}`;
    if (similarityScore !== undefined) {
      this._textStr += ` that matches to ${similarityScore} %`;
    }

    return new FluentFiltersOrRelationsCondition(this);
  }

  /**
   * Filters for texts, which match the regex pattern.
   *
   * **Examples:**
   *
   * ```typescript
   * 'The rain in Spain' === withTextRegex('\b[Ss]\w+') => true
   * 'The rain in Portugal' === withTextRegex('\b[Ss]\w+') => false
   * 'The rain in switzerland' === withTextRegex('\b[Ss]\w+') => true
   *
   * await aui.get().text().withTextRegex('\b[Ss]\w+').exec()
   * ```
   *
   * ![](https://docs.askui.com/img/gif/withTextRegex.gif)
   *
   *
   *
   * @param {string} regex_pattern - A regex pattern
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  withTextRegex(regex_pattern: string): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'match';
    this._textStr += ' regex';
    this._textStr += ' pattern';
    this._textStr += ` ${Separators.STRING}${regex_pattern}${Separators.STRING}`;

    return new FluentFiltersOrRelationsCondition(this);
  }

  /**
   * Filters for equal text.
   *
   * **Note:** This should be only used in cases where the similarity
   *  comparison of {@link FluentFilters.withText()} allows not for
   *  specific enough filtering (too many elements).
   *
   * **Examples:**
   * ```typescript
   * 'text' === withExactText('text') => true
   * 'test' === withExactText('text') => false
   * 'other' === withExactText('text') => false
   *
   * await aui.moveMouseTo().text().withExactText('Password').exec()
   * ```
   *
   * ![](https://docs.askui.com/img/gif/withExactText.gif)
   *
   *
   *
   * @param {string} text - A text to be matched.
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  withExactText(text: string): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'equals';
    this._textStr += ' text';
    this._textStr += ` ${Separators.STRING}${text}${Separators.STRING}`;

    return new FluentFiltersOrRelationsCondition(this);
  }

  /**
   * Filters for text containing the text provided as an argument.
   *
   * **Examples:**
   * ```typescript
   * 'This is a text' === containsText('text') => true
   * 'This is a text' === containsText('other text') => false
   * 'This is a text' === containsText('other') => false
   * ```
   * ![](https://docs.askui.com/img/gif/containsText.gif)
   *
   * @param {string} text - A text to be matched.
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  containsText(text: string): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'contain';
    this._textStr += ' text';
    this._textStr += ` ${Separators.STRING}${text}${Separators.STRING}`;

    return new FluentFiltersOrRelationsCondition(this);
  }

  /**
   * Filters elements based on a textual description.
   *
   * **What Should I Write as Matching Text**
   *
   * The text description inside the `matching()` should describe the element visually.
   * It understands color, some famous company/product names, general descriptions.
   *
   * **Important: _Matching only returns the best matching element when you use it with `get()`_**
   *
   * A bit of playing around to find a matching description is sometimes needed:
   * For example, `puzzle piece` can fail while `an icon showing a puzzle piece` might work.
   * Generally, the more detail the better.
   *
   * We also recommend to not restrict the type of element by using the general selector `element()` as shown in the examples below.
   *
   * **Examples:**
   * ```typescript
   * // Select the black sneaker from a bunch of sneakers
   * await aui.click().element().matching('a black sneaker shoe').exec();
   *
   * // Select an image that has text in it
   * await aui.click().element().matching('has Burger King in it').exec();
   * await aui.click().element().matching('has adidas in it').exec();
   *
   * // Target a logo/image by describing it
   * await aui.click().element().matching('a mask on purple background and a firefox logo').exec();
   * await aui.click().element().matching('logo looking like an apple with one bite bitten off').exec();
   * await aui.click().element().matching('logo looking like a seashell').exec();
   * ```
   *
   * @param {string} text - A description of the target element.
   *
   * @return {FluentFiltersOrRelationsCondition}
   */
  matching(text: string): FluentFiltersOrRelationsCondition {
    this._textStr = '';

    this._textStr += 'matching';
    this._textStr += ` ${Separators.STRING}${text}${Separators.STRING}`;

    return new FluentFiltersOrRelationsCondition(this);
  }
}

// Relations

export class FluentFiltersOrRelationsCondition extends FluentFiltersCondition {
  /**
   * Logic or operator
   *
   * **Examples:**
   * ```text
   * scene 1
   * --------------  ---------------
   * |  button    |  |  icon       |
   * --------------  ---------------
   *
   * scene 2
   * --------------  ---------------
   * |  button    |  |  text       |
   * --------------  ---------------
   *
   * ```
   * In case, that your reference element can have multiple values, in the following example, the element right of the button can be either icon or text.
   * You can use **the `or()` relation**, so your instruction is valid for both scenes
   * ```typescript
   * const button = await aui.get().button().rightOf().icon().or().text().exec();
   * console.log(button);
   * ```
   * Returns the same button for both cases
   * ```text
   *  console output: [
   *   DetectedElement {
   *      name: 'BUTTON',
   *      text: 'button',
   *      bndbox: BoundingBox {
   *         xmin: 900,
   *         ymin: 910,
   *         xmax: 920,
   *         ymax: 930
   *      }
   *   }
   *  ]
   * ```
   *
   * @return {FluentFiltersCondition}
   */
  or(): FluentFiltersCondition {
    this._textStr = '';

    this._textStr += 'or';

    return new FluentFiltersCondition(this);
  }

  /**
   * Logic and operator
   *
   * **Examples:**
   * ```text
   * example scene:
   *  ---------------   ----------------
   *  |  icon user  |   |  icon search |
   *  ---------------   ----------------
   * ```
   * ```typescript
   * const icons = await aui.get().icon().exec();
   * console.log(icons);
   * ```
   * Using only the element-description icon, the get will return both icons
   * ```text
   * console output: [
   *   DetectedElement {
   *      name: 'ICON',
   *      text: 'user',
   *      bndbox: BoundingBox {
   *         xmin: 1000,
   *         ymin: 1010,
   *         xmax: 1020,
   *         ymax: 1030
   *      }
   *   },
   *   DetectedElement {
   *      name: 'ICON',
   *      text: 'search',
   *      bndbox: BoundingBox {
   *         xmin: 900,
   *         ymin: 910,
   *         xmax: 920,
   *         ymax: 930
   *      }
   *   }
   *  ]
   * ```
   * You can combine element-descriptions with **the `and()` relation** and specify exactly which icon you want.
   * ```typescript
   * const icons = await aui.get().icon().and().withText('user').exec()
   * console.log(icons)
   * ```
   * The get returns only the user icon although both elements are icons.
   * ```text
   *  console output: [
   *   DetectedElement {
   *      name: 'ICON',
   *      text: 'user',
   *      bndbox: BoundingBox {
   *         xmin: 900,
   *         ymin: 910,
   *         xmax: 920,
   *         ymax: 930
   *      }
   *   }
   *  ]
   * ```
   *
   * @return {FluentFiltersCondition}
   */
  and(): FluentFiltersCondition {
    this._textStr = '';

    this._textStr += 'and';

    return new FluentFiltersCondition(this);
  }

  /**
   * Filters for an element inside another element.
   *
   * **Examples:**
   * ```typescript
   * --------------------
   * |     outerEl      |
   * |  --------------  |
   * |  |  innerEl   |  |
   * |  --------------  |
   * |                  |
   * --------------------
   *
   * // Returns innerEl because innerEl is inside outerEl
   * ...innerEl().in().outerEl()
   * // Returns nothing because innerEl is not inside outerEl
   * ...outerEl().in().innerEl()
   * ```
   * ![](https://docs.askui.com/img/gif/in.gif)
   *
   * @return {FluentFiltersCondition}
   */
  in(): FluentFiltersCondition {
    this._textStr = '';

    this._textStr += 'in';

    return new FluentFiltersCondition(this);
  }

  /**
   * Filters for an element right of another element.
   *
   * Takes an optional parameter `index` to select the nth element (defaults to `0`).
   *
   * Takes an optional parameter `intersection_area` to specify which elements right of the other element are filtered for based on their vertical position (y-coordinates of bounding box):
   * - `"element_center_line"` - considered right of the other element if element's bounding box intersects with a horizontal line passing through the center of the other element
   * - `"element_edge_area"` - considered right of the other element if element's bounding box intersects with an area between the top and the bottom edge of the other element
   * - `"display_edge_area"` - considered right of the other element no matter where it is placed vertically on the screen (y-axis)
   *
   * **Examples:**
   * ```typescript
   * ---------- ---------                     ---------
   * | button | | text0 |                     | text3 |
   * ---------- --------- ---------           ---------
   *                      | text1 | ---------
   *                      --------- | text2 |
   *                                ---------
   *
   * // General explanation for element_center_line
   * // This will find text0 and text3
   * ...text().rightOf(..., 'element_center_line').button()
   *
   * // General explanation for element_edge_area
   * // This will find text0, text1 and text3
   * ...text().rightOf(..., 'element_edge_area').button()
   *
   * // General explanation and display_edge_area
   * // This will find text0, text1, text2 and text3
   * ...text().rightOf(..., 'display_edge_area').button()
   *
   * // More examples:
   * // Returns text0 because it is the first element rightOf button
   * ...text().rightOf().button()
   * ...text().rightOf(0).button()
   * ...text().rightOf(0, 'element_edge_area').button()
   *
   * // Returns text3 because it is the second text touched by the
   * // horizontal line from the center of button
   * // Notice: text1 is not touched!
   * ...text().rightOf(1, 'element_center_line').button()
   *
   * // Returns text3 because it is the third text touched by the
   * // vertical area rightOf the y-axis of button
   * // Notice: text2 is not touched!
   * ...text().rightOf(2, 'element_edge_area').button()
   *
   * // Returns text2 because it is the third element rightOf button
   * ...text().rightOf(2, 'display_edge_area').button()
   *
   * // Returns no element because button is rightOf the texts
   * ...button().rightOf().text()
   * ```
   * ![](https://docs.askui.com/img/gif/rightOf.gif)
   *
   * @param {number} [index=0] - Index of element to filter for going into the direction specified. Defaults to `0` which is the first element (zero-indexed) found in that direction.
   * @param {INTERSECTION_AREA} [intersection_area="element_edge_area"] - Intersecting with either `"element_center_line"`, `"element_edge_area"` or `"display_edge_area"`. Defaults to `"element_edge_area"`.
   *
   * @return {FluentFiltersCondition}
   */
  rightOf(
    index = 0,
    intersection_area: INTERSECTION_AREA = 'element_edge_area',
  ): FluentFiltersCondition {
    this._textStr = '';

    if (index !== undefined) {
      this._textStr += `index ${index}`;
    }
    this._textStr += ' right';
    this._textStr += ' of';
    if (intersection_area !== undefined) {
      this._textStr += ` intersection_area ${intersection_area}`;
    }

    return new FluentFiltersCondition(this);
  }

  /**
   * Filters for an element left of another element.
   *
   * Takes an optional parameter `index` to select the nth element (defaults to `0`).
   *
   * Takes an optional parameter `intersection_area` to specify which elements left of the other element are filtered for based on their vertical position (y-coordinates of bounding box):
   * - `"element_center_line"` - considered left of the other element if element's bounding box intersects with a horizontal line passing through the center of the other element
   * - `"element_edge_area"` - considered left of the other element if element's bounding box intersects with an area between the top and the bottom edge of the other element
   * - `"display_edge_area"` - considered left of the other element no matter where it is placed vertically on the screen (y-axis)
   *
   * **Examples:**
   * ```typescript
   * ---------                   --------- ----------
   * | text3 |                   | text0 | | button |
   * ---------         --------- --------- ----------
   *         --------- | text1 |
   *         | text2 | ---------
   *         ---------
   *
   * // General explanation for element_center_line
   * // This will find text0 and text3
   * ...text().leftOf(..., 'element_center_line').button()
   *
   * // General explanation for element_edge_area
   * // This will find text0, text1 and text3
   * ...text().leftOf(..., 'element_edge_area').button()
   *
   * // General explanation and display_edge_area
   * // This will find text0, text1, text2 and text3
   * ...text().leftOf(..., 'display_edge_area').button()
   *
   * // More examples:
   * // Returns text0 because it is the first element leftOf button
   * ...text().leftOf().button()
   * ...text().leftOf(0).button()
   * ...text().leftOf(0, 'element_edge_area').button()
   *
   * // Returns text3 because it is the second text touched by the
   * // horizontal line from the center of button
   * // Notice: text1 is not touched!
   * ...text().leftOf(1, 'element_center_line').button()
   *
   * // Returns text3 because it is the third text touched by the
   * // vertical area leftOf the y-axis of button
   * // Notice: text2 is not touched!
   * ...text().leftOf(2, 'element_edge_area').button()
   *
   * // Returns text2 because it is the third element leftOf button
   * ...text().leftOf(2, 'display_edge_area').button()
   *
   * // Returns no element because button is rightOf the texts
   * ...button().leftOf().text()
   * ```
   * ![](https://docs.askui.com/img/gif/leftOf.gif)
   *
   * @param {number} [index=0] - Index of element to filter for going into the direction specified. Defaults to `0` which is the first element (zero-indexed) found in that direction.
   * @param {INTERSECTION_AREA} [intersection_area="element_edge_area"] - Intersecting with either `"element_center_line"`, `"element_edge_area"` or `"display_edge_area"`. Defaults to `"element_edge_area"`.
   *
   * @return {FluentFiltersCondition}
   */
  leftOf(
    index = 0,
    intersection_area: INTERSECTION_AREA = 'element_edge_area',
  ): FluentFiltersCondition {
    this._textStr = '';

    if (index !== undefined) {
      this._textStr += `index ${index}`;
    }
    this._textStr += ' left';
    this._textStr += ' of';
    if (intersection_area !== undefined) {
      this._textStr += ` intersection_area ${intersection_area}`;
    }

    return new FluentFiltersCondition(this);
  }

  /**
   * Filters for an element below another element.
   *
   * Takes an optional parameter `index` to select the nth element (defaults to `0`).
   *
   * Takes an optional parameter `intersection_area` to specify which elements below of the other element are filtered for based on their horizontal position (y-coordinates of bounding box):
   * - `"element_center_line"` - considered below of the other element if element's bounding box intersects with a vertical line passing through the center of the other element
   * - `"element_edge_area"` - considered below of the other element if element's bounding box intersects with an area between the left and the right edge of the other element
   * - `"display_edge_area"` - considered below of the other element no matter where it is placed horizontally on the screen (y-axis)
   *
   * **Examples:**
   * ```typescript
   * ------------
   * |   text   |
   * ------------
   * ------------
   * |  button0 |
   * ------------
   *          -----------
   *          | button1 |
   *          -----------
   *             -----------
   *             | button2 |
   *             -----------
   * ------------
   * |  button3 |
   * ------------
   *
   * // General explanation for element_center_line
   * // This will find button0 and button3
   * ...button().below(..., 'element_center_line').text()
   *
   * // General explanation for element_edge_area
   * // This will find button0, button1 and button3
   * ...button().below(..., 'element_edge_area').text()
   *
   * // General explanation and display_edge_area
   * // This will find button0, button1, button2 and button3
   * ...button().below(..., 'display_edge_area').text()
   *
   * // More examples:
   * // Returns button0 because button0 is the first button below text
   * ...button().below().text()
   * ...button().below(0).text()
   * ...button().below(0, 'element_edge_area').text()
   *
   * // Returns button3 because it is the second button touched by the
   * // vertical line from the center of text
   * // Notice: button1 is not touched
   * ...button().below(1, 'element_center_line').text()
   *
   * // Returns button3 because it is the third button touched by the
   * // vertical area below the x-axis of text
   * // Notice: button2 is not touched!
   * ...button().below(2, 'element_edge_area').text()
   *
   * // Returns button2 because it is the third element below text
   * ...button().below(2, 'display_edge_area').text()
   *
   * // Returns no element because text is above the buttons
   * ...text().below().button()
   * ```
   * ![](https://docs.askui.com/img/gif/below.gif)
   *
   * @param {number} [index=0] - Index of element to filter for going into the direction specified. Defaults to `0` which is the first element (zero-indexed) found in that direction.
   * @param {INTERSECTION_AREA} [intersection_area="element_edge_area"] - Intersecting with either `"element_center_line"`, `"element_edge_area"` or `"display_edge_area"`. Defaults to `"element_edge_area"`.
   *
   * @return {FluentFiltersCondition}
   */
  below(
    index = 0,
    intersection_area: INTERSECTION_AREA = 'element_edge_area',
  ): FluentFiltersCondition {
    this._textStr = '';

    if (index !== undefined) {
      this._textStr += `index ${index}`;
    }
    this._textStr += ' below';
    if (intersection_area !== undefined) {
      this._textStr += ` intersection_area ${intersection_area}`;
    }

    return new FluentFiltersCondition(this);
  }

  /**
   * Filters for an element above another element.
   *
   * Takes an optional parameter `index` to select the nth element (defaults to `0`).
   *
   * Takes an optional parameter `intersection_area` to specify which elements above of the other element are filtered for based on their horizontal position (y-coordinates of bounding box):
   * - `"element_center_line"` - considered above of the other element if element's bounding box intersects with a vertical line passing through the center of the other element
   * - `"element_edge_area"` - considered above of the other element if element's bounding box intersects with an area between the left and the right edge of the other element
   * - `"display_edge_area"` - considered above of the other element no matter where it is placed horizontally on the screen (y-axis)
   *
   * **Examples:**
   * ```typescript
   * ------------
   * |  text3   |
   * ------------
   *             ------------
   *             |  text2   |
   *             ------------
   *     ------------
   *     |  text1   |
   *     ------------
   * ------------
   * |  text0   |
   * ------------
   * ------------
   * |  button  |
   * ------------
   *
   * // General explanation for element_center_line
   * // This will find text0 and text3
   * ...text().above(..., 'element_center_line').button()
   *
   * // General explanation for element_edge_area
   * // This will find text0, text1 and text3
   * ...text().above(..., 'element_edge_area').button()
   *
   * // General explanation and display_edge_area
   * // This will find text0, text1, text2 and text3
   * ...text().above(..., 'display_edge_area').button()
   *
   * // More examples:
   * // Returns text0 because it is the first element above button
   * ...text().above().button()
   * ...text().above(0).button()
   * ...text().above(0, 'element_edge_area').button()
   *
   * // Returns text3 because it is the second text touched by the
   * // vertical line from the center of button
   * // Notice: text1 is not touched!
   * ...text().above(1, 'element_center_line').button()
   *
   * // Returns text3 because it is the third text touched by the
   * // vertical area above the x-axis of button
   * // Notice: text2 is not touched!
   * ...text().above(2, 'element_edge_area').button()
   *
   * // Returns text2 because it is the third element above button
   * ...text().above(2, 'display_edge_area').button()
   *
   * // Returns no element because button is below the texts
   * ...button().above().text()
   * ```
   * ![](https://docs.askui.com/img/gif/above.gif)
   *
   * @param {number} [index=0] - Index of element to filter for going into the direction specified. Defaults to `0` which is the first element (zero-indexed) found in that direction.
   * @param {INTERSECTION_AREA} [intersection_area="element_edge_area"] - Intersecting with either `"element_center_line"`, `"element_edge_area"` or `"display_edge_area"`. Defaults to `"element_edge_area"`.
   *
   * @return {FluentFiltersCondition}
   */
  above(
    index = 0,
    intersection_area: INTERSECTION_AREA = 'element_edge_area',
  ): FluentFiltersCondition {
    this._textStr = '';

    if (index !== undefined) {
      this._textStr += `index ${index}`;
    }
    this._textStr += ' above';
    if (intersection_area !== undefined) {
      this._textStr += ` intersection_area ${intersection_area}`;
    }

    return new FluentFiltersCondition(this);
  }

  /**
   * Filters for an element nearest to another element.
   *
   * **Examples:**
   * ```typescript
   * --------------
   * |  button 1  |
   * --------------
   * --------------
   * |   text     |
   * --------------
   *
   *
   *
   * --------------
   * |  button 2  |
   * --------------
   *
   * // Returns button 1 because button 1 is nearer to the text than button 2
   * ...button().nearestTo().text()
   * ```
   * ![](https://docs.askui.com/img/gif/nearestTo.gif)
   *
   * @return {FluentFiltersCondition}
   */
  nearestTo(): FluentFiltersCondition {
    this._textStr = '';

    this._textStr += 'nearest';
    this._textStr += ' to';

    return new FluentFiltersCondition(this);
  }

  /**
   * Filters for an element containing another element.
   *
   * **Example:**
   * ```typescript
   * --------------------
   * |     outerEl      |
   * |  --------------  |
   * |  |  innerEl   |  |
   * |  --------------  |
   * |                  |
   * --------------------
   *
   * // Returns outerEl because outerEl contains innerEl
   * ...outerEl().contains().innerEl()
   * //  Returns no element because innerEl contains no outerEl
   * ...innerEl().contains().outerEl()
   * ```
   * ![](https://docs.askui.com/img/gif/contains.gif)
   *
   * @return {FluentFiltersCondition}
   */
  contains(): FluentFiltersCondition {
    this._textStr = '';

    this._textStr += 'contains';

    return new FluentFiltersCondition(this);
  }

  /**
   * Expects that filtered element exists.
   *
   * Always use together with `expect()`.
   *
   * **Note** Throws an error and stops the execution when the element is not found. You can catch the error and decide what to do as in the examples below.
   *
   * **Examples:**
   * ```typescript
   * // Stops execution at this point when the element does not exist.
   * await aui.expect().text('Login').exists().exec()
   *
   * // This will catch the error and log a message
   * // But the execution will continue afterwards
   * try {
   *     await aui.expect().text('Login').exists().exec()
   * } catch (error) {
   *     console.log('Too bad we could not find the element!');
   * }
   * ```
   *
   * @return {ExecCondition}
   */
  exists(): ExecCondition {
    this._textStr = '';

    this._textStr += 'exists';

    return new ExecCondition(this);
  }

  /**
   * Expects that filtered element not exists.
   *
   * Always use together with `expect()`.
   *
   * **Note** Throws an error and stops the execution when the element is found. You can catch the error and decide what to do as in the examples below.
   *
   * **Examples:**
   * ```typescript
   * // Stops execution at this point when the element does exist.
   * await aui.expect().text('Login').notExists().exec()
   *
   * // This will catch the error and log a message
   * // But the execution will continue afterwards
   * try {
   *     await aui.expect().text('Login').notExists().exec()
   * } catch (error) {
   *     console.log('Too bad we could find the element!');
   * }
   * ```
   *
   * @return {ExecCondition}
   */
  notExists(): ExecCondition {
    this._textStr = '';

    this._textStr += 'not';
    this._textStr += ' exists';

    return new ExecCondition(this);
  }
}

class ExecCondition extends Exec {}

// Commands
export abstract class FluentCommand extends FluentBase {
  constructor() {
    super(undefined);
  }

  /**
   * Expects a condition, for example, `exists()` or `notExits()`.
   *
   * Use the structure `expect().<your filter>.(exists()|notExists())` as shown in the examples below.
   *
   * **Examples:**
   * ```typescript
   * await aui.expect().text('Login').exists().exec()
   * await aui.expect().text('Login').notExists().exec()
   * ```
   *
   * @return {FluentFiltersCondition}
   */
  expect(): FluentFiltersCondition {
    this._textStr = '';

    this._textStr += 'Expect';

    return new FluentFiltersCondition(this);
  }

  /**
   * Mouse left-clicks/taps on the filtered element by moving the mouse cursor to the filtered element first.
   *
   * If you need a simple mouseleftclick/tap only, use `mouseLeftClick`.
   *
   * **Example:**
   * ```typescript
   * await aui.click().button().withText('Google Search').exec();
   * ```
   *
   * ![](https://docs.askui.com/img/gif/click.gif)
   *
   *
   *
   * @return {FluentFilters}
   */
  click(): FluentFilters {
    this._textStr = '';

    this._textStr += 'Click';
    this._textStr += ' on';

    return new FluentFilters(this);
  }

  /**
   * Move mouse over the filtered element.
   *
   * **Example:**
   * ```typescript
   * await aui.moveMouseTo().text().withText('Grinning_Face').exec()
   * ```
   *
   * ![](https://docs.askui.com/img/gif/moveMouseTo.gif)
   *
   *
   *
   * @return {FluentFilters}
   */
  moveMouseTo(): FluentFilters {
    this._textStr = '';

    this._textStr += 'Move';
    this._textStr += ' mouse';
    this._textStr += ' to';

    return new FluentFilters(this);
  }

  /**
   * Puts the focus on the filtered element and types in the text.
   *
   * **Note:** In the current version it copies the text and pastes it.
   *
   * **Examples:**
   * ```typescript
   * await aui.typeIn('Type some text').textfield().exec()
   *
   * // mask the text so it is not send to the askui-inference server
   * await aui.typeIn('Type some text', { isSecret: true, secretMask: '**' }).textfield().exec()
   * ```
   * ![](https://docs.askui.com/img/gif/typeIn.gif)
   *
   * @param {string} text - A text to type
   *
   * @return {FluentFilters}
   */
  typeIn(text: string): FluentFilters {
    this._textStr = '';

    this._textStr += 'Type';
    this._textStr += ` ${Separators.STRING}${text}${Separators.STRING}`;
    this._textStr += ' in';

    return new FluentFilters(this);
  }

  /**
   * Moves mouse to the filtered element and scrolls in the x and y direction.
   *
   * **macOS**: May not work as expected!
   *
   * **Example:**
   * ```typescript
   * await aui.scrollInside(0,-500).text().withText('Bottom sheet').exec();
   * ```
   *
   * ![](https://docs.askui.com/img/gif/scrollInside.gif)
   *
   * @param {number} x_offset - A (positive/negative) x direction.
   * @param {number} y_offset - A (positive/negative) y direction.
   *
   * @return {FluentFilters}
   */
  scrollInside(x_offset: number, y_offset: number): FluentFilters {
    this._textStr = '';

    this._textStr += 'Scroll';
    this._textStr += ' x';
    this._textStr += ` ${x_offset}`;
    this._textStr += ' y';
    this._textStr += ` ${y_offset}`;
    this._textStr += ' in';

    return new FluentFilters(this);
  }

  /**
   * Moves the mouse relatively to an element in the direction.
   * This can be used when the mouse should not hover over an element anymore.
   *
   * **Examples:**
   * ```typescript
   * // Move mouse 30 pixels below button
   * await aui.moveMouseRelativelyTo(0, 30).button().withText('Submit').exec()
   * ```
   * ![](https://docs.askui.com/img/gif/moveMouseRelativelyTo.gif)
   *
   * @param {number} x_offset - A (positive/negative) x direction.
   * @param {number} y_offset - A (positive/negative) y direction.
   *
   * @return {FluentFilters}
   */
  moveMouseRelativelyTo(x_offset: number, y_offset: number): FluentFilters {
    this._textStr = '';

    this._textStr += 'Move';
    this._textStr += ' mouse';
    this._textStr += ' x';
    this._textStr += ` ${x_offset}`;
    this._textStr += ' y';
    this._textStr += ` ${y_offset}`;
    this._textStr += ' relatively to';

    return new FluentFilters(this);
  }

  /**
   * Swipe an element in the x and y direction.
   * Holds the left mouse button down on Windows, Linux and macOS and drags the element.
   * On touch devices it taps the element and then drags it.
   *
   * **Example:**
   * ```typescript
   * // Swipe the element 500 to the right
   * await aui.swipe(500, 0).image().exec()
   * ```
   * ![](https://docs.askui.com/img/gif/swipe.gif)
   *
   * @param {number} x_offset - A x direction. positive and negative values are accepted
   * @param {number} y_offset - A y direction. positive and negative values are accepted
   *
   * @return {FluentFilters}
   */
  swipe(x_offset: number, y_offset: number): FluentFilters {
    this._textStr = '';

    this._textStr += 'Swipe';
    this._textStr += ' x';
    this._textStr += ` ${x_offset}`;
    this._textStr += ' y';
    this._textStr += ` ${y_offset}`;

    return new FluentFilters(this);
  }

  /**
   * Types a text at the current position.
   * If you need to focus the element first, use typeIn()
   *
   * **Note:** In the current version it copies the text and pastes it.
   *
   * **Examples:**
   * ```typescript
   * await aui.type('askui@askui.com').exec()
   *
   * // mask the text so it is not send to the askui-inference server
   * await aui.type('Type some text', { isSecret: true, secretMask: '**' }).exec()
   * ```
   *
   * ![](https://docs.askui.com/img/gif/type.gif)
   *
   * @param {string} text - A text to type
   *
   * @return {Exec}
   */
  type(text: string): Exec {
    this._textStr = '';

    this._textStr += 'Type';
    this._textStr += ` ${Separators.STRING}${text}${Separators.STRING}`;

    return new Exec(this);
  }

  /**
   * Moves the mouse from the current position (relative) in x and y direction.
   *
   * **Example:**
   * ```typescript
   * await aui.moveMouseRelatively(0, 50).exec();
   * ```
   *
   * ![](https://docs.askui.com/img/gif/moveMouseRelatively.gif)
   *
   * @param {number} x_offset - A (positive/negative) x direction.
   * @param {number} y_offset - A (positive/negative) y direction.
   *
   * @return {Exec}
   */
  moveMouseRelatively(x_offset: number, y_offset: number): Exec {
    this._textStr = '';

    this._textStr += 'Move';
    this._textStr += ' mouse';
    this._textStr += ' from';
    this._textStr += ' current';
    this._textStr += ' position';
    this._textStr += ' with';
    this._textStr += ' x';
    this._textStr += ` ${x_offset}`;
    this._textStr += ' y';
    this._textStr += ` ${y_offset}`;

    return new Exec(this);
  }

  /**
   * Moves the mouse to the absolute x and y coordinates.
   *
   * If you want to move your mouse cursor to an element, use `moveMouseTo()`.
   *
   * **Example:**
   * ```typescript
   * await aui.moveMouse(500, 500).exec();
   * ```
   *
   * ![](https://docs.askui.com/img/gif/moveMouse.gif)
   *
   * @param {number} x_coordinate - A (positive/negative) x coordinate.
   * @param {number} y_coordinate - A (positive/negative) y coordinate.
   *
   * @return {Exec}
   */
  moveMouse(x_coordinate: number, y_coordinate: number): Exec {
    this._textStr = '';

    this._textStr += 'Move';
    this._textStr += ' mouse';
    this._textStr += ' to';
    this._textStr += ' x';
    this._textStr += ` ${x_coordinate}`;
    this._textStr += ' y';
    this._textStr += ` ${y_coordinate}`;

    return new Exec(this);
  }

  /**
   * Scrolls based on the current mouse position in the x and y direction.
   *
   * **Important**: Mouse must be positioned in a scrollable area.
   *
   * **macOS**: May not work as expected!
   *
   * **Example:**
   * ```typescript
   * // Scroll 500 pixels down in y direction
   * await aui.scroll(0, -500).exec()
   * ```
   *
   * ![](https://docs.askui.com/img/gif/scroll.gif)
   *
   * @param {number} x_offset - A (positive/negative) x direction.
   * @param {number} y_offset - A (positive/negative) y direction.
   *
   * @return {Exec}
   */
  scroll(x_offset: number, y_offset: number): Exec {
    this._textStr = '';

    this._textStr += 'Scroll';
    this._textStr += ' x';
    this._textStr += ` ${x_offset}`;
    this._textStr += ' y';
    this._textStr += ` ${y_offset}`;

    return new Exec(this);
  }

  /**
   * Executes a shell command on the device your AskUI Controller is connected to.
   *
   * **Example:**
   * ```typescript
   * // Open the lastpass app
   * await aui.execOnShell('monkey -p com.lastpass.authenticator 1').exec();
   *
   * // Open Google Chrome on Windows
   * await aui.execOnShell("start chrome").exec()
   *
   * ;// Open Google Chrome on macOS
   * await aui.execOnShell("open -a 'Google Chrome'").exec();
   *
   * // Open Google Chrome on Linux
   * await aui.execOnShell("chrome").exec();
   * ```
   *
   * @param {string} shellCommand - A shell command which is executed.
   * @param {number} [timeoutInMilliseconds=1] - A timeout in milliseconds.
   *
   * @return {Exec}
   */
  execOnShell(
    shellCommand: string,
    timeoutInMilliseconds
    = 1,
  ): Exec {
    this._textStr = '';

    this._textStr += 'Execute';
    this._textStr += ' shell';
    this._textStr += ' command';
    this._textStr += ` ${Separators.STRING}${shellCommand}${Separators.STRING}`;
    if (timeoutInMilliseconds !== undefined) {
      this._textStr += ` with ${timeoutInMilliseconds} milliseconds timeout`;
    }

    return new Exec(this);
  }

  /**
   * Clicks with left mouse key.
   *
   * If you need to move the mouse first, use `moveMouseTo()`.
   *
   * **Examples:**
   * ```typescript
   * // Optional: Move mouse to an element first
   * await aui.moveMouseTo().button().withText('Login').exec();
   *
   * await aui.mouseLeftClick().exec();
   * ```
   *
   * @return {Exec}
   */
  mouseLeftClick(): Exec {
    this._textStr = '';

    this._textStr += 'Mouse left click';

    return new Exec(this);
  }

  /**
   * Clicks with right mouse key.
   *
   * If you need to move the mouse first, use `moveMouseTo()`.
   *
   * **Examples:**
   * ```typescript
   * // Optional: Move mouse to an element first
   * await aui.moveMouseTo().button().withText('Login').exec();
   *
   * await aui.mouseRightClick().exec();
   * ```
   *
   * @return {Exec}
   */
  mouseRightClick(): Exec {
    this._textStr = '';

    this._textStr += 'Mouse right click';

    return new Exec(this);
  }

  /**
   * Clicks with middle mouse key.
   *
   * If you need to move the mouse first, use `moveMouseTo()`.
   *
   * **Examples:**
   * ```typescript
   * // Optional: Move mouse to an element first
   * await aui.moveMouseTo().button().withText('Login').exec();
   *
   * await aui.mouseMiddleClick().exec();
   * ```
   *
   * @return {Exec}
   */
  mouseMiddleClick(): Exec {
    this._textStr = '';

    this._textStr += 'Mouse middle click';

    return new Exec(this);
  }

  /**
   * Double-clicks with left mouse key.
   *
   * If you need to move the mouse first, use `moveMouseTo()`.
   *
   * **Examples:**
   * ```typescript
   * // Optional: Move mouse to an element first
   * await aui.moveMouseTo().button().withText('Login').exec();
   *
   * await aui.mouseDoubleLeftClick().exec();
   * ```
   *
   * ![](https://docs.askui.com/img/gif/mouseDoubleLeftClick.gif)
   *
   * @return {Exec}
   */
  mouseDoubleLeftClick(): Exec {
    this._textStr = '';

    this._textStr += 'Mouse double left click';

    return new Exec(this);
  }

  /**
   * Double-clicks with right mouse key.
   *
   * If you need to move the mouse first, use `moveMouseTo()`.
   *
   * **Examples:**
   * ```typescript
   * // Optional: Move mouse to an element first
   * await aui.moveMouseTo().button().withText('Login').exec();
   *
   * await aui.mouseDoubleRightClick().exec();
   * ```
   *
   * @return {Exec}
   */
  mouseDoubleRightClick(): Exec {
    this._textStr = '';

    this._textStr += 'Mouse double right click';

    return new Exec(this);
  }

  /**
   * Double-clicks with middle mouse key.
   *
   * If you need to move the mouse first, use `moveMouseTo()`.
   *
   * **Examples:**
   * ```typescript
   * // Optional: Move mouse to an element first
   * await aui.moveMouseTo().button().withText('Login').exec();
   *
   * await aui.mouseDoubleMiddleClick().exec();
   * ```
   *
   * @return {Exec}
   */
  mouseDoubleMiddleClick(): Exec {
    this._textStr = '';

    this._textStr += 'Mouse double middle click';

    return new Exec(this);
  }

  /**
   * Toggles mouse down (Left mouse key/tap).
   *
   *  This is the equivalent to **mouse-left-press-and-hold**. It holds the mouse button until the `mouseToogleUp()` is called. Often combined with `mouseToggleUP` to automate **drag-and-drop**.
   *
   * **Example:**
   * ```typescript
   * await aui.mouseToggleDown().exec();
   * await aui.moveMouseRelatively(-400,0).exec();
   * await aui.mouseToggleUp().exec();
   * ```
   *
   * ![](https://docs.askui.com/img/gif/mouseToggleDownUp.gif)
   *
   * @return {Exec}
   */
  mouseToggleDown(): Exec {
    this._textStr = '';

    this._textStr += 'Mouse toggle down';

    return new Exec(this);
  }

  /**
   * Toggles mouse up (Left mouse key/tap).
   *
   * This is the equivalent to releasing the pressing mouse left button. Often combined with `mouseToggleDown()` to automate **drag-and-drop**.
   *
   * **Example:**
   * ```typescript
   * await aui.mouseToggleDown().exec();
   * await aui.moveMouseRelatively(-400,0).exec();
   * await aui.mouseToggleUp().exec();
   * ```
   *
   * ![](https://docs.askui.com/img/gif/mouseToggleDownUp.gif)
   *
   * @return {Exec}
   */
  mouseToggleUp(): Exec {
    this._textStr = '';

    this._textStr += 'Mouse toggle up';

    return new Exec(this);
  }

  /**
   * Press three keys like `CTRL+ALT+DEL`
   *
   * **Operating system specific mappings:**
   * 1. Windows: `command`-key maps to `windows`-key
   *
   * **Examples:**
   * ```typescript
   * await aui.pressThreeKeys('control', 'command' 'space').exec();
   * ```
   *
   * ![](https://docs.askui.com/img/gif/pressThreeKeys.gif)
   *
   * @param {MODIFIER_KEY} first_key - A modifier key
   * @param {MODIFIER_KEY} second_key - A modifier key
   * @param {PC_KEY} third_key - A key
   *
   * @return {Exec}
   */
  pressThreeKeys(
    first_key: MODIFIER_KEY,
    second_key: MODIFIER_KEY,
    third_key: PC_KEY,
  ): Exec {
    this._textStr = '';

    this._textStr += 'Press';
    this._textStr += ' key';
    this._textStr += ` ${first_key}`;
    this._textStr += ` ${second_key}`;
    this._textStr += ` ${third_key}`;

    return new Exec(this);
  }

  /**
   * Press two keys like `ALT+F4`
   *
   * **Operating system specific mappings:**
   * 1. Windows: `command`-key maps to `windows`-key
   * ---
   *
   *
   * @param {MODIFIER_KEY} first_key - A modifier key
   * @param {PC_KEY} second_key - A key
   *
   * @return {Exec}
   */
  pressTwoKeys(first_key: MODIFIER_KEY, second_key: PC_KEY): Exec {
    this._textStr = '';

    this._textStr += 'Press';
    this._textStr += ' key';
    this._textStr += ` ${first_key}`;
    this._textStr += ` ${second_key}`;

    return new Exec(this);
  }

  /**
   * Press one keys like `DEL`
   *
   * **Operating system specific mappings:**
   * 1. Windows: `command`-key maps to `windows`-key
   *
   * **Examples:**
   * ```typescript
   * await aui.pressKey('tab').exec();
   * ```
   *
   * ![](https://docs.askui.com/img/gif/pressKey.gif)
   *
   * @param {PC_AND_MODIFIER_KEY} key - A key
   *
   * @return {Exec}
   */
  pressKey(key: PC_AND_MODIFIER_KEY): Exec {
    this._textStr = '';

    this._textStr += 'Press';
    this._textStr += ' key';
    this._textStr += ` ${key}`;

    return new Exec(this);
  }

  /**
   * Press three Android keys like `CTRL+ALT+DEL`
   *
   * @param {ANDROID_KEY} first_key - A Android key
   * @param {ANDROID_KEY} second_key - A Android key
   * @param {ANDROID_KEY} third_key - A Android key
   *
   * @return {Exec}
   */
  pressAndroidThirdKey(
    first_key: ANDROID_KEY,
    second_key: ANDROID_KEY,
    third_key: ANDROID_KEY,
  ): Exec {
    this._textStr = '';

    this._textStr += 'Press';
    this._textStr += ' android';
    this._textStr += ' key';
    this._textStr += ` ${first_key}`;
    this._textStr += ` ${second_key}`;
    this._textStr += ` ${third_key}`;

    return new Exec(this);
  }

  /**
   * Press two Android keys like `volume_down+power`
   * See [API docs](https://docs.askui.com/docs/api/Actions/pressandroidtwokey) for available keys.
   *
   * **Examples:**
   * ```typescript
   * await aui.pressAndroidTwoKey('volume_down', 'power').exec();
   * ```
   *
   * ![](https://docs.askui.com/img/gif/pressAndroidTwoKeys.gif)
   *
   * @param {ANDROID_KEY} first_key - A Android key
   * @param {ANDROID_KEY} second_key - A Android key
   *
   * @return {Exec}
   */
  pressAndroidTwoKey(first_key: ANDROID_KEY, second_key: ANDROID_KEY): Exec {
    this._textStr = '';

    this._textStr += 'Press';
    this._textStr += ' android';
    this._textStr += ' key';
    this._textStr += ` ${first_key}`;
    this._textStr += ` ${second_key}`;

    return new Exec(this);
  }

  /**
   * Press one Android key like `del`
   * See [API docs](https://docs.askui.com/docs/api/Actions/pressandroidtwokey) for available keys.
   *
   * **Examples:**
   * ```typescript
   * await aui.pressAndroidKey('notification').exec();
   * ```
   *
   * ![](https://docs.askui.com/img/gif/pressAndroidKey.gif)
   *
   * @param {ANDROID_KEY} key - A Android key
   *
   * @return {Exec}
   */
  pressAndroidKey(key: ANDROID_KEY): Exec {
    this._textStr = '';

    this._textStr += 'Press';
    this._textStr += ' android';
    this._textStr += ' key';
    this._textStr += ` ${key}`;

    return new Exec(this);
  }

  abstract fluentCommandExecutor(
    instruction: string,
    context: CommandExecutorContext
  ): Promise<void>;
}

// Getters
export interface ExecutableGetter {
  exec(): Promise<DetectedElement[]>;
}

export class ExecGetter extends FluentBase implements ExecutableGetter {
  exec(): Promise<DetectedElement[]> {
    return this.getterStringBuilder();
  }
}
// Filters

export class FluentFiltersGetter extends FluentBase {
  /**
   * Filters for a UI element 'other element'.
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  otherElement(): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'other';
    this._textStr += ' element';

    return new FluentFiltersOrRelationsGetter(this);
  }

  /**
   * Filters for a UI element 'switch'.
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  switch(): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'switch';

    return new FluentFiltersOrRelationsGetter(this);
  }

  /**
   * Filters for a UI element 'container'.
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  container(): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'container';

    return new FluentFiltersOrRelationsGetter(this);
  }

  /**
   * Filters for a UI element 'checkbox'.
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  checkbox(): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'checkbox';

    return new FluentFiltersOrRelationsGetter(this);
  }

  /**
   * Filters for any UI element on the screen.
   *
   * **Examples:**
   * ```typescript
   * await aui.moveMouseTo().element().exec()
   * ```
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  element(): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'element';

    return new FluentFiltersOrRelationsGetter(this);
  }

  /**
   * Filters special elements defined over a specifically trained custom element descriptor.
   *
   * Custom element descriptors are trained on your elements that were not detected with our
   * default models. Please contact us for further details on how to do this. We are working on
   * a solution to provide this in our User Portal.
   *
   * In the example below circle refers to a circle shaped icon with specific properties.
   *
   * **Examples:**
   * ```typescript
   * await aui.moveMouseTo().element().special("circle").exec()
   * ```
   *
   * @param {string} text - A text to be matched.
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  special(text: string): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'special';
    this._textStr += ` ${Separators.STRING}${text}${Separators.STRING}`;

    return new FluentFiltersOrRelationsGetter(this);
  }

  /**
   * Filters for a UI element 'button'.
   *
   * **Examples:**
   * ```typescript
   * await aui.click().button().contains().text().withText('Google Search').exec()
   * ```
   *
   * ![](https://docs.askui.com/img/gif/button.gif)
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  button(): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'button';

    return new FluentFiltersOrRelationsGetter(this);
  }

  /**
   *
   * @param {number} index - element index
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  row(index: number): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'row';
    this._textStr += ` ${index}`;

    return new FluentFiltersOrRelationsGetter(this);
  }

  /**
   *
   * @param {number} index - element index
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  column(index: number): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'column';
    this._textStr += ` ${index}`;

    return new FluentFiltersOrRelationsGetter(this);
  }

  /**
   *
   * @param {number} row_index - row index
   * @param {number} column_index - column index
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  cell(
    row_index: number,
    column_index: number,
  ): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'cell';
    this._textStr += ' row';
    this._textStr += ` ${row_index}`;
    this._textStr += ' column';
    this._textStr += ` ${column_index}`;

    return new FluentFiltersOrRelationsGetter(this);
  }

  /**
   * Filters for a UI element 'table'.
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  table(): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'table';

    return new FluentFiltersOrRelationsGetter(this);
  }

  /**
   * Filters for an UI element 'text'.
   *
   * Takes an optional parameter to filter for a specific text.
   * See the examples below.
   *
   * See also the filters `withTextRegex()` and `withExactText()`
   *
   * **Examples:**
   * ```typescript
   * await aui.click().text().exec();
   * await aui.click().text('Username').exec();
   *
   * // Matching with an exact text
   * await aui.click().text().withExactText('Username').exec();
   *
   * // Matching with a regex
   * await aui.click().text().withTextRegex('\b[Ss]\w+').exec();
   * ```
   *
   * @param {string} [text] - A text to be matched.
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  text(text?: string): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'text';
    if (text !== undefined) {
      this._textStr += ` ${Separators.STRING}${text}${Separators.STRING}`;
    }

    return new FluentFiltersOrRelationsGetter(this);
  }

  /**
   * Filters for a UI element 'icon'.
   *
   * You can combine it with the element-description 'withText()' to look for a specific icon.
   *
   * **Examples:**
   * ```typescript
   * icon().withText('plus')
   * ```
   *
   * ![](https://docs.askui.com/img/gif/icon.gif)
   *
   * **Note:** This is an alpha feature. The prediction of the icon name is sometimes unstable. Use custom elements as an alternative.
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  icon(): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'icon';

    return new FluentFiltersOrRelationsGetter(this);
  }

  /**
   * Filters for a 'custom element', that is a UI element that is defined by providing an image and other parameters such as degree of rotation. It allows filtering for a UI element based on an image instead of using text or element descriptions like `button().withText('Submit')` in `await aui.click().button().withText('Submit').exec()`.
   *
   * See the tutorial - [Custom Element](https://docs.askui.com/docs/general/Element%20Selection/custom-elements) for more details.
   *
   * **Example**
   * ```typescript
   * await aui
   *     .click()
   *     .customElement({
   *         customImage: './logo.png', // required
   *         name: 'myLogo', // optional
   *         threshold: 0.5, // optional, defaults to 0.5
   *         stopThreshold: 0.9, // optional, defaults to 0.9
   *         rotationDegreePerStep: 0, // optional, defaults to 0
   *         imageCompareFormat: 'grayscale', // optional, defaults to 'grayscale'
   *         // mask:{x:0, y:0}[] // optional, a polygon to match only a certain area of the custom element
   *     })
   *     .exec();
   * ```
   *
   * **Arguments**
   *
   * - **customImage** (*`string`, required*):
   *     - A cropped image in the form of a base64 string or file path.
   * - **name** (*`string`, optional*):
   *     - A unique name that can be used for filtering for the custom element. If not given, any text inside the custom image will be detected via OCR.
   * - **threshold** (*`number`, optional*):
   *     - A threshold for how much a UI element needs to be similar to the custom element as defined by the image. Takes values between `0.0` (== all elements are recognized as the custom element which is probably not what you want) and `1.0` (== elements need to look exactly like the `customImage` which is unlikely to be achieved as even minor differences count). Defaults to `0.5`.
   * - **stopThreshold** (*`number`, optional*):
   *     - A threshold for when to stop searching for UI elements similar to the custom element. As soon as UI elements have been found that are at least as similar as the `stopThreshold`, the search is going to stop. After that elements are filtered using the `threshold`. Because of that the `stopThreshold` should be greater than or equal to `threshold`. It is primarily to be used as a speed improvement (by lowering the value). Takes values between `0.0` and `1.0`. Defaults to `0.9`.
   * - **rotationDegreePerStep** (*`number`, optional*):
   *     - Step size in rotation degree. Rotates the custom image by this step size until 360° is exceeded. The range is from `0` to `360`. Defaults to `0`.
   * - **imageCompareFormat** (*`'RGB' | 'grayscale' | 'edges'`, optional*):
   *     - The color compare style. `'edges'` compares only edges, `'greyscale'` compares the brightness of each pixel whereas `'RGB'` compares all three colors (red, green, blue). Defaults to `'grayscale'`.
   *
   *
   * @param {CustomElementJson} customElement - The custom element to filter for.
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  customElement(
    customElement: CustomElementJson,
  ): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'custom';
    this._textStr += ' element';

    this._params.set('customElement', customElement);
    return new FluentFiltersOrRelationsGetter(this);
  }

  /**
   * Detects an AI Element created with the [snipping workflow](https://docs.askui.com/docs/general/Components/aielement#snipping-workflow).
   *
   * **Examples:**
   *
   * ```typescript
   * await aui.click().aiElement('askui-logo').exec();
   * ```
   *
   * @param {string} aiElementName - Name of the AI Element.
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  aiElement(aiElementName: string): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'ai';
    this._textStr += ' element';
    this._textStr += ' with';
    this._textStr += ' name';
    this._textStr += ` ${Separators.STRING}${aiElementName}${Separators.STRING}`;

    this._params.set('aiElementName', aiElementName);
    return new FluentFiltersOrRelationsGetter(this);
  }

  /**
   * Filters for a UI element 'image'.
   *
   * **Examples:**
   * ```typescript
   * // Works if there is only one image visible on the screen
   * await aui.click().image().exec();
   *
   * // Works if you have an image with
   * // a text below
   * await aui.click().image().above().text().withText('Automating WebGL').exec();
   * ```
   *
   * ![](https://docs.askui.com/img/gif/image.gif)
   *
   *
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  image(): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'image';

    return new FluentFiltersOrRelationsGetter(this);
  }

  /**
   * Filters for a UI element 'textfield'.
   *
   * **Examples:**
   * ```typescript
   * // Works if there is only one textfield visible on the screen
   * await aui.typeIn('Oh yeah').textfield().exec();
   *
   * // Works if you have a labeled textfield
   * // Label is above the textfield
   * await aui.typeIn('Oh yeah').textfield().below().text().withText('E-Mail Address').exec();
   * ```
   *
   * ![](https://docs.askui.com/img/gif/textfield.gif)
   *
   *
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  textfield(): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'textfield';

    return new FluentFiltersOrRelationsGetter(this);
  }

  /**
   * Filters for similar -- meaning >70% similar -- text.
   *
   * Takes an optional parameter to specify the similarity. Usually you need the optional parameter for long texts you want to match precisely.
   *
   * _We use [RapidFuzz](https://maxbachmann.github.io/RapidFuzz/Usage/fuzz.html#ratio) which calculates the similarity like this:_
   *
   * `1 - (distance / (lengthString1 + lengthString2))`
   *
   * **Examples:**
   * ```typescript
   * 'text' === withText('text') => true
   * 'test' === withText('text') => true
   * 'Test' === withText('text') => true
   * 'Text' === withText('text') => true
   * 'TEXT' === withText('text') => true
   * 'texst' === withText('text') => true
   * 'texts' === withText('text') => true
   *
   * // usually false
   * 'atebxtc' === withText('text') => false
   * 'other' === withText('text') => false
   *
   * // optional parameter: similarity_score
   * '978-0-201-00650-6' == withText("978-0-201-00", 90) => false with 82.76 < 90 similarity
   * '978-0-201-00650-6' == withText("978-0-201-00650", 90) => true with 93.75 > 90 similarity
   * ```
   * ![](https://docs.askui.com/img/gif/withText.gif)
   *
   * @param {string} text - A text to be matched.
   * @param {number} [similarityScore=70] - Similarity score minimum value, it should be between `0` and `100`.
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  withText(
    text: string,
    similarityScore = 70,
  ): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'with';
    this._textStr += ' text';
    this._textStr += ` ${Separators.STRING}${text}${Separators.STRING}`;
    if (similarityScore !== undefined) {
      this._textStr += ` that matches to ${similarityScore} %`;
    }

    return new FluentFiltersOrRelationsGetter(this);
  }

  /**
   * Filters for texts, which match the regex pattern.
   *
   * **Examples:**
   *
   * ```typescript
   * 'The rain in Spain' === withTextRegex('\b[Ss]\w+') => true
   * 'The rain in Portugal' === withTextRegex('\b[Ss]\w+') => false
   * 'The rain in switzerland' === withTextRegex('\b[Ss]\w+') => true
   *
   * await aui.get().text().withTextRegex('\b[Ss]\w+').exec()
   * ```
   *
   * ![](https://docs.askui.com/img/gif/withTextRegex.gif)
   *
   *
   *
   * @param {string} regex_pattern - A regex pattern
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  withTextRegex(regex_pattern: string): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'match';
    this._textStr += ' regex';
    this._textStr += ' pattern';
    this._textStr += ` ${Separators.STRING}${regex_pattern}${Separators.STRING}`;

    return new FluentFiltersOrRelationsGetter(this);
  }

  /**
   * Filters for equal text.
   *
   * **Note:** This should be only used in cases where the similarity
   *  comparison of {@link FluentFilters.withText()} allows not for
   *  specific enough filtering (too many elements).
   *
   * **Examples:**
   * ```typescript
   * 'text' === withExactText('text') => true
   * 'test' === withExactText('text') => false
   * 'other' === withExactText('text') => false
   *
   * await aui.moveMouseTo().text().withExactText('Password').exec()
   * ```
   *
   * ![](https://docs.askui.com/img/gif/withExactText.gif)
   *
   *
   *
   * @param {string} text - A text to be matched.
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  withExactText(text: string): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'equals';
    this._textStr += ' text';
    this._textStr += ` ${Separators.STRING}${text}${Separators.STRING}`;

    return new FluentFiltersOrRelationsGetter(this);
  }

  /**
   * Filters for text containing the text provided as an argument.
   *
   * **Examples:**
   * ```typescript
   * 'This is a text' === containsText('text') => true
   * 'This is a text' === containsText('other text') => false
   * 'This is a text' === containsText('other') => false
   * ```
   * ![](https://docs.askui.com/img/gif/containsText.gif)
   *
   * @param {string} text - A text to be matched.
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  containsText(text: string): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'contain';
    this._textStr += ' text';
    this._textStr += ` ${Separators.STRING}${text}${Separators.STRING}`;

    return new FluentFiltersOrRelationsGetter(this);
  }

  /**
   * Filters elements based on a textual description.
   *
   * **What Should I Write as Matching Text**
   *
   * The text description inside the `matching()` should describe the element visually.
   * It understands color, some famous company/product names, general descriptions.
   *
   * **Important: _Matching only returns the best matching element when you use it with `get()`_**
   *
   * A bit of playing around to find a matching description is sometimes needed:
   * For example, `puzzle piece` can fail while `an icon showing a puzzle piece` might work.
   * Generally, the more detail the better.
   *
   * We also recommend to not restrict the type of element by using the general selector `element()` as shown in the examples below.
   *
   * **Examples:**
   * ```typescript
   * // Select the black sneaker from a bunch of sneakers
   * await aui.click().element().matching('a black sneaker shoe').exec();
   *
   * // Select an image that has text in it
   * await aui.click().element().matching('has Burger King in it').exec();
   * await aui.click().element().matching('has adidas in it').exec();
   *
   * // Target a logo/image by describing it
   * await aui.click().element().matching('a mask on purple background and a firefox logo').exec();
   * await aui.click().element().matching('logo looking like an apple with one bite bitten off').exec();
   * await aui.click().element().matching('logo looking like a seashell').exec();
   * ```
   *
   * @param {string} text - A description of the target element.
   *
   * @return {FluentFiltersOrRelationsGetter}
   */
  matching(text: string): FluentFiltersOrRelationsGetter {
    this._textStr = '';

    this._textStr += 'matching';
    this._textStr += ` ${Separators.STRING}${text}${Separators.STRING}`;

    return new FluentFiltersOrRelationsGetter(this);
  }
}

// Relations

export class FluentFiltersOrRelationsGetter extends FluentFiltersGetter {
  /**
   * Logic or operator
   *
   * **Examples:**
   * ```text
   * scene 1
   * --------------  ---------------
   * |  button    |  |  icon       |
   * --------------  ---------------
   *
   * scene 2
   * --------------  ---------------
   * |  button    |  |  text       |
   * --------------  ---------------
   *
   * ```
   * In case, that your reference element can have multiple values, in the following example, the element right of the button can be either icon or text.
   * You can use **the `or()` relation**, so your instruction is valid for both scenes
   * ```typescript
   * const button = await aui.get().button().rightOf().icon().or().text().exec();
   * console.log(button);
   * ```
   * Returns the same button for both cases
   * ```text
   *  console output: [
   *   DetectedElement {
   *      name: 'BUTTON',
   *      text: 'button',
   *      bndbox: BoundingBox {
   *         xmin: 900,
   *         ymin: 910,
   *         xmax: 920,
   *         ymax: 930
   *      }
   *   }
   *  ]
   * ```
   *
   * @return {FluentFiltersGetter}
   */
  or(): FluentFiltersGetter {
    this._textStr = '';

    this._textStr += 'or';

    return new FluentFiltersGetter(this);
  }

  /**
   * Logic and operator
   *
   * **Examples:**
   * ```text
   * example scene:
   *  ---------------   ----------------
   *  |  icon user  |   |  icon search |
   *  ---------------   ----------------
   * ```
   * ```typescript
   * const icons = await aui.get().icon().exec();
   * console.log(icons);
   * ```
   * Using only the element-description icon, the get will return both icons
   * ```text
   * console output: [
   *   DetectedElement {
   *      name: 'ICON',
   *      text: 'user',
   *      bndbox: BoundingBox {
   *         xmin: 1000,
   *         ymin: 1010,
   *         xmax: 1020,
   *         ymax: 1030
   *      }
   *   },
   *   DetectedElement {
   *      name: 'ICON',
   *      text: 'search',
   *      bndbox: BoundingBox {
   *         xmin: 900,
   *         ymin: 910,
   *         xmax: 920,
   *         ymax: 930
   *      }
   *   }
   *  ]
   * ```
   * You can combine element-descriptions with **the `and()` relation** and specify exactly which icon you want.
   * ```typescript
   * const icons = await aui.get().icon().and().withText('user').exec()
   * console.log(icons)
   * ```
   * The get returns only the user icon although both elements are icons.
   * ```text
   *  console output: [
   *   DetectedElement {
   *      name: 'ICON',
   *      text: 'user',
   *      bndbox: BoundingBox {
   *         xmin: 900,
   *         ymin: 910,
   *         xmax: 920,
   *         ymax: 930
   *      }
   *   }
   *  ]
   * ```
   *
   * @return {FluentFiltersGetter}
   */
  and(): FluentFiltersGetter {
    this._textStr = '';

    this._textStr += 'and';

    return new FluentFiltersGetter(this);
  }

  /**
   * Filters for an element inside another element.
   *
   * **Examples:**
   * ```typescript
   * --------------------
   * |     outerEl      |
   * |  --------------  |
   * |  |  innerEl   |  |
   * |  --------------  |
   * |                  |
   * --------------------
   *
   * // Returns innerEl because innerEl is inside outerEl
   * ...innerEl().in().outerEl()
   * // Returns nothing because innerEl is not inside outerEl
   * ...outerEl().in().innerEl()
   * ```
   * ![](https://docs.askui.com/img/gif/in.gif)
   *
   * @return {FluentFiltersGetter}
   */
  in(): FluentFiltersGetter {
    this._textStr = '';

    this._textStr += 'in';

    return new FluentFiltersGetter(this);
  }

  /**
   * Filters for an element right of another element.
   *
   * Takes an optional parameter `index` to select the nth element (defaults to `0`).
   *
   * Takes an optional parameter `intersection_area` to specify which elements right of the other element are filtered for based on their vertical position (y-coordinates of bounding box):
   * - `"element_center_line"` - considered right of the other element if element's bounding box intersects with a horizontal line passing through the center of the other element
   * - `"element_edge_area"` - considered right of the other element if element's bounding box intersects with an area between the top and the bottom edge of the other element
   * - `"display_edge_area"` - considered right of the other element no matter where it is placed vertically on the screen (y-axis)
   *
   * **Examples:**
   * ```typescript
   * ---------- ---------                     ---------
   * | button | | text0 |                     | text3 |
   * ---------- --------- ---------           ---------
   *                      | text1 | ---------
   *                      --------- | text2 |
   *                                ---------
   *
   * // General explanation for element_center_line
   * // This will find text0 and text3
   * ...text().rightOf(..., 'element_center_line').button()
   *
   * // General explanation for element_edge_area
   * // This will find text0, text1 and text3
   * ...text().rightOf(..., 'element_edge_area').button()
   *
   * // General explanation and display_edge_area
   * // This will find text0, text1, text2 and text3
   * ...text().rightOf(..., 'display_edge_area').button()
   *
   * // More examples:
   * // Returns text0 because it is the first element rightOf button
   * ...text().rightOf().button()
   * ...text().rightOf(0).button()
   * ...text().rightOf(0, 'element_edge_area').button()
   *
   * // Returns text3 because it is the second text touched by the
   * // horizontal line from the center of button
   * // Notice: text1 is not touched!
   * ...text().rightOf(1, 'element_center_line').button()
   *
   * // Returns text3 because it is the third text touched by the
   * // vertical area rightOf the y-axis of button
   * // Notice: text2 is not touched!
   * ...text().rightOf(2, 'element_edge_area').button()
   *
   * // Returns text2 because it is the third element rightOf button
   * ...text().rightOf(2, 'display_edge_area').button()
   *
   * // Returns no element because button is rightOf the texts
   * ...button().rightOf().text()
   * ```
   * ![](https://docs.askui.com/img/gif/rightOf.gif)
   *
   * @param {number} [index=0] - Index of element to filter for going into the direction specified. Defaults to `0` which is the first element (zero-indexed) found in that direction.
   * @param {INTERSECTION_AREA} [intersection_area="element_edge_area"] - Intersecting with either `"element_center_line"`, `"element_edge_area"` or `"display_edge_area"`. Defaults to `"element_edge_area"`.
   *
   * @return {FluentFiltersGetter}
   */
  rightOf(
    index = 0,
    intersection_area: INTERSECTION_AREA = 'element_edge_area',
  ): FluentFiltersGetter {
    this._textStr = '';

    if (index !== undefined) {
      this._textStr += `index ${index}`;
    }
    this._textStr += ' right';
    this._textStr += ' of';
    if (intersection_area !== undefined) {
      this._textStr += ` intersection_area ${intersection_area}`;
    }

    return new FluentFiltersGetter(this);
  }

  /**
   * Filters for an element left of another element.
   *
   * Takes an optional parameter `index` to select the nth element (defaults to `0`).
   *
   * Takes an optional parameter `intersection_area` to specify which elements left of the other element are filtered for based on their vertical position (y-coordinates of bounding box):
   * - `"element_center_line"` - considered left of the other element if element's bounding box intersects with a horizontal line passing through the center of the other element
   * - `"element_edge_area"` - considered left of the other element if element's bounding box intersects with an area between the top and the bottom edge of the other element
   * - `"display_edge_area"` - considered left of the other element no matter where it is placed vertically on the screen (y-axis)
   *
   * **Examples:**
   * ```typescript
   * ---------                   --------- ----------
   * | text3 |                   | text0 | | button |
   * ---------         --------- --------- ----------
   *         --------- | text1 |
   *         | text2 | ---------
   *         ---------
   *
   * // General explanation for element_center_line
   * // This will find text0 and text3
   * ...text().leftOf(..., 'element_center_line').button()
   *
   * // General explanation for element_edge_area
   * // This will find text0, text1 and text3
   * ...text().leftOf(..., 'element_edge_area').button()
   *
   * // General explanation and display_edge_area
   * // This will find text0, text1, text2 and text3
   * ...text().leftOf(..., 'display_edge_area').button()
   *
   * // More examples:
   * // Returns text0 because it is the first element leftOf button
   * ...text().leftOf().button()
   * ...text().leftOf(0).button()
   * ...text().leftOf(0, 'element_edge_area').button()
   *
   * // Returns text3 because it is the second text touched by the
   * // horizontal line from the center of button
   * // Notice: text1 is not touched!
   * ...text().leftOf(1, 'element_center_line').button()
   *
   * // Returns text3 because it is the third text touched by the
   * // vertical area leftOf the y-axis of button
   * // Notice: text2 is not touched!
   * ...text().leftOf(2, 'element_edge_area').button()
   *
   * // Returns text2 because it is the third element leftOf button
   * ...text().leftOf(2, 'display_edge_area').button()
   *
   * // Returns no element because button is rightOf the texts
   * ...button().leftOf().text()
   * ```
   * ![](https://docs.askui.com/img/gif/leftOf.gif)
   *
   * @param {number} [index=0] - Index of element to filter for going into the direction specified. Defaults to `0` which is the first element (zero-indexed) found in that direction.
   * @param {INTERSECTION_AREA} [intersection_area="element_edge_area"] - Intersecting with either `"element_center_line"`, `"element_edge_area"` or `"display_edge_area"`. Defaults to `"element_edge_area"`.
   *
   * @return {FluentFiltersGetter}
   */
  leftOf(
    index = 0,
    intersection_area: INTERSECTION_AREA = 'element_edge_area',
  ): FluentFiltersGetter {
    this._textStr = '';

    if (index !== undefined) {
      this._textStr += `index ${index}`;
    }
    this._textStr += ' left';
    this._textStr += ' of';
    if (intersection_area !== undefined) {
      this._textStr += ` intersection_area ${intersection_area}`;
    }

    return new FluentFiltersGetter(this);
  }

  /**
   * Filters for an element below another element.
   *
   * Takes an optional parameter `index` to select the nth element (defaults to `0`).
   *
   * Takes an optional parameter `intersection_area` to specify which elements below of the other element are filtered for based on their horizontal position (y-coordinates of bounding box):
   * - `"element_center_line"` - considered below of the other element if element's bounding box intersects with a vertical line passing through the center of the other element
   * - `"element_edge_area"` - considered below of the other element if element's bounding box intersects with an area between the left and the right edge of the other element
   * - `"display_edge_area"` - considered below of the other element no matter where it is placed horizontally on the screen (y-axis)
   *
   * **Examples:**
   * ```typescript
   * ------------
   * |   text   |
   * ------------
   * ------------
   * |  button0 |
   * ------------
   *          -----------
   *          | button1 |
   *          -----------
   *             -----------
   *             | button2 |
   *             -----------
   * ------------
   * |  button3 |
   * ------------
   *
   * // General explanation for element_center_line
   * // This will find button0 and button3
   * ...button().below(..., 'element_center_line').text()
   *
   * // General explanation for element_edge_area
   * // This will find button0, button1 and button3
   * ...button().below(..., 'element_edge_area').text()
   *
   * // General explanation and display_edge_area
   * // This will find button0, button1, button2 and button3
   * ...button().below(..., 'display_edge_area').text()
   *
   * // More examples:
   * // Returns button0 because button0 is the first button below text
   * ...button().below().text()
   * ...button().below(0).text()
   * ...button().below(0, 'element_edge_area').text()
   *
   * // Returns button3 because it is the second button touched by the
   * // vertical line from the center of text
   * // Notice: button1 is not touched
   * ...button().below(1, 'element_center_line').text()
   *
   * // Returns button3 because it is the third button touched by the
   * // vertical area below the x-axis of text
   * // Notice: button2 is not touched!
   * ...button().below(2, 'element_edge_area').text()
   *
   * // Returns button2 because it is the third element below text
   * ...button().below(2, 'display_edge_area').text()
   *
   * // Returns no element because text is above the buttons
   * ...text().below().button()
   * ```
   * ![](https://docs.askui.com/img/gif/below.gif)
   *
   * @param {number} [index=0] - Index of element to filter for going into the direction specified. Defaults to `0` which is the first element (zero-indexed) found in that direction.
   * @param {INTERSECTION_AREA} [intersection_area="element_edge_area"] - Intersecting with either `"element_center_line"`, `"element_edge_area"` or `"display_edge_area"`. Defaults to `"element_edge_area"`.
   *
   * @return {FluentFiltersGetter}
   */
  below(
    index = 0,
    intersection_area: INTERSECTION_AREA = 'element_edge_area',
  ): FluentFiltersGetter {
    this._textStr = '';

    if (index !== undefined) {
      this._textStr += `index ${index}`;
    }
    this._textStr += ' below';
    if (intersection_area !== undefined) {
      this._textStr += ` intersection_area ${intersection_area}`;
    }

    return new FluentFiltersGetter(this);
  }

  /**
   * Filters for an element above another element.
   *
   * Takes an optional parameter `index` to select the nth element (defaults to `0`).
   *
   * Takes an optional parameter `intersection_area` to specify which elements above of the other element are filtered for based on their horizontal position (y-coordinates of bounding box):
   * - `"element_center_line"` - considered above of the other element if element's bounding box intersects with a vertical line passing through the center of the other element
   * - `"element_edge_area"` - considered above of the other element if element's bounding box intersects with an area between the left and the right edge of the other element
   * - `"display_edge_area"` - considered above of the other element no matter where it is placed horizontally on the screen (y-axis)
   *
   * **Examples:**
   * ```typescript
   * ------------
   * |  text3   |
   * ------------
   *             ------------
   *             |  text2   |
   *             ------------
   *     ------------
   *     |  text1   |
   *     ------------
   * ------------
   * |  text0   |
   * ------------
   * ------------
   * |  button  |
   * ------------
   *
   * // General explanation for element_center_line
   * // This will find text0 and text3
   * ...text().above(..., 'element_center_line').button()
   *
   * // General explanation for element_edge_area
   * // This will find text0, text1 and text3
   * ...text().above(..., 'element_edge_area').button()
   *
   * // General explanation and display_edge_area
   * // This will find text0, text1, text2 and text3
   * ...text().above(..., 'display_edge_area').button()
   *
   * // More examples:
   * // Returns text0 because it is the first element above button
   * ...text().above().button()
   * ...text().above(0).button()
   * ...text().above(0, 'element_edge_area').button()
   *
   * // Returns text3 because it is the second text touched by the
   * // vertical line from the center of button
   * // Notice: text1 is not touched!
   * ...text().above(1, 'element_center_line').button()
   *
   * // Returns text3 because it is the third text touched by the
   * // vertical area above the x-axis of button
   * // Notice: text2 is not touched!
   * ...text().above(2, 'element_edge_area').button()
   *
   * // Returns text2 because it is the third element above button
   * ...text().above(2, 'display_edge_area').button()
   *
   * // Returns no element because button is below the texts
   * ...button().above().text()
   * ```
   * ![](https://docs.askui.com/img/gif/above.gif)
   *
   * @param {number} [index=0] - Index of element to filter for going into the direction specified. Defaults to `0` which is the first element (zero-indexed) found in that direction.
   * @param {INTERSECTION_AREA} [intersection_area="element_edge_area"] - Intersecting with either `"element_center_line"`, `"element_edge_area"` or `"display_edge_area"`. Defaults to `"element_edge_area"`.
   *
   * @return {FluentFiltersGetter}
   */
  above(
    index = 0,
    intersection_area: INTERSECTION_AREA = 'element_edge_area',
  ): FluentFiltersGetter {
    this._textStr = '';

    if (index !== undefined) {
      this._textStr += `index ${index}`;
    }
    this._textStr += ' above';
    if (intersection_area !== undefined) {
      this._textStr += ` intersection_area ${intersection_area}`;
    }

    return new FluentFiltersGetter(this);
  }

  /**
   * Filters for an element nearest to another element.
   *
   * **Examples:**
   * ```typescript
   * --------------
   * |  button 1  |
   * --------------
   * --------------
   * |   text     |
   * --------------
   *
   *
   *
   * --------------
   * |  button 2  |
   * --------------
   *
   * // Returns button 1 because button 1 is nearer to the text than button 2
   * ...button().nearestTo().text()
   * ```
   * ![](https://docs.askui.com/img/gif/nearestTo.gif)
   *
   * @return {FluentFiltersGetter}
   */
  nearestTo(): FluentFiltersGetter {
    this._textStr = '';

    this._textStr += 'nearest';
    this._textStr += ' to';

    return new FluentFiltersGetter(this);
  }

  /**
   * Filters for an element containing another element.
   *
   * **Example:**
   * ```typescript
   * --------------------
   * |     outerEl      |
   * |  --------------  |
   * |  |  innerEl   |  |
   * |  --------------  |
   * |                  |
   * --------------------
   *
   * // Returns outerEl because outerEl contains innerEl
   * ...outerEl().contains().innerEl()
   * //  Returns no element because innerEl contains no outerEl
   * ...innerEl().contains().outerEl()
   * ```
   * ![](https://docs.askui.com/img/gif/contains.gif)
   *
   * @return {FluentFiltersGetter}
   */
  contains(): FluentFiltersGetter {
    this._textStr = '';

    this._textStr += 'contains';

    return new FluentFiltersGetter(this);
  }

  /**
   * Returns a list of detected elements
   *
   * @return {DetectedElement[]}
   */
  exec(): Promise<DetectedElement[]> {
    return this.getterStringBuilder();
  }
}

// Commands
export abstract class Getter extends FluentCommand {
  /**
   * Returns an array with all filtered elements.
   * A detected element has the following properties:
   * - `name` of the element
   * - `text` content of element
   * - `bndbox`: location of element described with coordinates of a bounding box
   *
   * **Examples:**
   * ```typescript
   * // ************************************ //
   * // Log the DetectedElements completely  //
   * // ************************************ //
   * const text = await aui.get().text('Sign').exec();
   * console.log(text);
   *
   * // Console output
   * [
   *   DetectedElement {
   *     name: 'TEXT',
   *     text: 'Sign In',
   *     bndbox: BoundingBox {
   *       xmin: 1128.2720982142857,
   *       ymin: 160.21332310267857,
   *       xmax: 1178.8204241071428,
   *       ymax: 180.83512834821428
   *     }
   *   }
   * ]
   * ```
   *
   * ```typescript
   * // *************************************************** //
   * // Examples on how to work with the returned elements  //
   * // *************************************************** //
   * const texts = await aui.get().text().below().textfield().exec();
   *
   * // We can get a lot of elements this way
   * console.log(texts);
   *
   * // Console output
   * [
   *   DetectedElement {
   *     name: 'TEXT',
   *     text: 'Sign In',
   *     bndbox: BoundingBox {
   *       xmin: 1128.2720982142857,
   *       ymin: 160.21332310267857,
   *       xmax: 1178.8204241071428,
   *       ymax: 180.83512834821428
   *     },
   *   },
   *   DetectedElement {
   *     name: 'TEXT',
   *     text: 'Login',
   *     bndbox: BoundingBox {
   *       xmin: 250.8204241071428,
   *       ymin: 300.21332310267857,
   *       xmax: 450.6304241071428,
   *       ymax: 950.47812834821428
   *     },
   *   },
   *   ... 10 more items
   * ]
   *
   * // Extract the FIRST element
   * // Arrays start with index 0!
   * const firstTextElement = texts[0];
   * const textOfFirstElement = firstElement.text;
   *
   * console.log(textOfFirstElement);
   *
   * // Console output
   * Sign In
   *
   * // Log the text of the SECOND element
   * // with shorter code
   * const texts = await aui.get().text().below().textfield().exec();
   * console.log(texts[1].text)
   *
   * // Console output
   * Login
   * ```
   *
   * @return {FluentFiltersGetter}
   */
  get(): FluentFiltersGetter {
    this._textStr = '';

    this._textStr += 'get';
    this._textStr += ' element';

    return new FluentFiltersGetter(this);
  }

  /**
   * Returns an array with all detected elements.
   * A detected element has the following properties:
   * - `name` of the element
   * - `text` content of element
   * - `bndbox`: location of element described with coordinates of a bounding box
   *
   * **Examples:**
   * ```typescript
   * const detectedElements = await aui.getAll().exec();
   * console.log(detectedElements);
   * ```
   * ```text
   *  console output: [
   *   DetectedElement {
   *      name: 'TEXT',
   *      text: 'Sign In',
   *      bndbox: BoundingBox {
   *         xmin: 1128.2720982142857,
   *         ymin: 160.21332310267857,
   *         xmax: 1178.8204241071428,
   *         ymax: 180.83512834821428
   *      },
   *   },
   *   DetectedElement {
   *      name: 'ICON',
   *      text: 'search',
   *      bndbox: BoundingBox {
   *         xmin: 250.8204241071428,
   *         ymin: 300.21332310267857,
   *         xmax: 450.6304241071428,
   *         ymax: 950.47812834821428
   *      },
   *    },
   *   ... 381 more items
   *  ]
   * ```
   *
   * @return {ExecGetter}
   */
  getAll(): ExecGetter {
    this._textStr = '';

    this._textStr += 'get';
    this._textStr += ' all';
    this._textStr += ' elements';

    return new ExecGetter(this);
  }

  abstract getterExecutor(
    instruction: string,
    context: CommandExecutorContext
  ): Promise<DetectedElement[]>;
}

export abstract class ApiCommands extends Getter {}
